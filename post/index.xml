<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on Jack&#39;s Note</title>
        <link>https://example.com/post/</link>
        <description>Recent content in Posts on Jack&#39;s Note</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-tw</language>
        <lastBuildDate>Thu, 22 May 2025 11:17:31 +0800</lastBuildDate><atom:link href="https://example.com/post/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>SQL vs NoSQL</title>
        <link>https://example.com/post/sql-vs-nosql/</link>
        <pubDate>Thu, 22 May 2025 11:17:31 +0800</pubDate>
        
        <guid>https://example.com/post/sql-vs-nosql/</guid>
        <description>&lt;h2 id=&#34;sql-structured-query-language&#34;&gt;SQL (Structured Query Language)
&lt;/h2&gt;&lt;p&gt;SQL 是指一種查詢語言，用來跟關聯式資料庫(RDBMS,Relational Database Management System)互動。&lt;/p&gt;
&lt;h3 id=&#34;rdbms-relational-database-management-system&#34;&gt;RDBMS (Relational Database Management System)
&lt;/h3&gt;&lt;p&gt;使用 Table 來儲存管理資料，Table 中會以表格的方式儲存資料，如下所示。&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;user_id&lt;/th&gt;
          &lt;th&gt;user_name&lt;/th&gt;
          &lt;th&gt;email&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;0&lt;/td&gt;
          &lt;td&gt;Jack&lt;/td&gt;
          &lt;td&gt;&lt;a class=&#34;link&#34; href=&#34;mailto:example@test.com&#34; &gt;example@test.com&lt;/a&gt;&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;同一欄位的資料，會規定是要相同的資料型態。&lt;/p&gt;
&lt;p&gt;每個表格會有一個 Primary Key，用來唯一識別每條資料。&lt;/p&gt;
&lt;p&gt;表格跟表格之間可以建立關聯(join)，表示表格可以特過特定的欄位資料來跟另一個表格相互關聯。&lt;/p&gt;
&lt;p&gt;以以下兩張表來做說明&lt;/p&gt;
&lt;p&gt;users&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;user_id&lt;/th&gt;
          &lt;th&gt;user_name&lt;/th&gt;
          &lt;th&gt;email&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;0&lt;/td&gt;
          &lt;td&gt;Jack&lt;/td&gt;
          &lt;td&gt;&lt;a class=&#34;link&#34; href=&#34;mailto:example@test.com&#34; &gt;example@test.com&lt;/a&gt;&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;user_detail&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;user_name&lt;/th&gt;
          &lt;th&gt;Age&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;Jack&lt;/td&gt;
          &lt;td&gt;28&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;假如想要查詢使用者姓名、電子郵件、年齡，可以透過 SQL 語法關聯。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;SELECT users.user_name, users.email, user_details.Age
FROM users
INNER JOIN user_details
ON users.user_name = user_details.user_name;
&lt;/code&gt;&lt;/pre&gt;&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;user_id&lt;/th&gt;
          &lt;th&gt;user_name&lt;/th&gt;
          &lt;th&gt;email&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;0&lt;/td&gt;
          &lt;td&gt;Jack&lt;/td&gt;
          &lt;td&gt;&lt;a class=&#34;link&#34; href=&#34;mailto:example@test.com&#34; &gt;example@test.com&lt;/a&gt;&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;RDBMS 具備 ACID 特性，在資料庫中，使用一筆交易(transaction)來指一組資料庫操作，以下以交易來解釋 ACID。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原子性(Atomicity):一筆交易中只要有任何操作失敗，就必須回滾(roll back)為交易前的狀態。&lt;/li&gt;
&lt;li&gt;一致性(Consistency):交易前後，資料庫必須保持一致的狀態，交易不會破壞資料庫的完整系。e.g. A 與 B 一共有 200 元，A 轉帳給 B，轉完帳後 A 與 B 依然一共有 200 元。&lt;/li&gt;
&lt;li&gt;隔離性(Isolation):交易之間不會互相干擾。每個交易的執行不應該被其他交易影響，isolation 可以再分為四個級別。&lt;/li&gt;
&lt;li&gt;持久性(Durability):只要資料寫入資料庫，即便是系統崩潰也不會丟失。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;index&#34;&gt;index
&lt;/h3&gt;&lt;p&gt;RDBMS 透過 B-Tree 資料結構來建立索引，並且可以依照排序來儲存索引。&lt;/p&gt;
&lt;h2 id=&#34;nosqlnot-only-sql&#34;&gt;NoSQL(Not only sql)
&lt;/h2&gt;&lt;p&gt;NoSQL 通常指的是不使用表格關聯方式來儲存資料的資料庫，儲存方式多元，以我自己常用的 mongodb 來講，是以 Json 的方式來儲存資料。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[
  {
    &amp;#34;user_id&amp;#34;: 1,
    &amp;#34;user_name&amp;#34;: &amp;#34;Alice&amp;#34;,
    &amp;#34;email&amp;#34;: &amp;#34;alice@example.com&amp;#34;,
    &amp;#34;age&amp;#34;: 30,
  },
  {
    &amp;#34;user_id&amp;#34;: 2,
    &amp;#34;user_name&amp;#34;: &amp;#34;Bob&amp;#34;,
    &amp;#34;email&amp;#34;: &amp;#34;bob@example.com&amp;#34;,
    &amp;#34;age&amp;#34;: 25,
  },
]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;mongodb 一開始並不支援 join，但是後來新增了 $lookup ，其行為類似於 SQL 的 JOIN。&lt;/p&gt;
&lt;p&gt;NoSQL 資料庫通常是用於在分散式系統，所以需要考慮 CAP。&lt;/p&gt;
&lt;h3 id=&#34;cap&#34;&gt;CAP
&lt;/h3&gt;&lt;p&gt;CAP 理論指的是在一個分散式系統中，只能保證以下三者其二。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一致性(Consistency):每次讀取操作都能取得系統中最新寫入的資料。&lt;/li&gt;
&lt;li&gt;可用性(Availability):每次對系統的請求都能得到回覆。&lt;/li&gt;
&lt;li&gt;分區容錯性(Partition Tolernce):當系統的不同節點支籤無法通訊，系統仍然能保持運作。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;index-1&#34;&gt;index
&lt;/h3&gt;&lt;p&gt;NoSQL 使用 Hash function 將資料轉換為 Hash value，但也因此 nosql 的索引是無序的。&lt;/p&gt;
&lt;h2 id=&#34;比較&#34;&gt;比較
&lt;/h2&gt;&lt;h3 id=&#34;縱向擴展-vertical-scaling&#34;&gt;縱向擴展 (Vertical Scaling)
&lt;/h3&gt;&lt;p&gt;縱向擴展指的是透過增加硬體提升效能(e.g.增加 CPU、memory&amp;hellip;)，來提升單個伺服器的效能。&lt;/p&gt;
&lt;p&gt;SQL : 支援，對於 SQL 資料庫來說垂直擴展是最能增加效能的方法，隨著資料量增加，對於硬體的需求也會逐漸提高。&lt;/p&gt;
&lt;p&gt;NoSQL : 支援&lt;/p&gt;
&lt;h3 id=&#34;橫向擴展-horizontal-scaling&#34;&gt;橫向擴展 (Horizontal Scaling)
&lt;/h3&gt;&lt;p&gt;橫向擴展指的是增加更多伺服器或節點來提升效能。&lt;/p&gt;
&lt;p&gt;SQL:支援但不擅長，因為要維持 ACID，而 ACID 在不同 server 之間要維持原子性會非常困難。&lt;/p&gt;
&lt;p&gt;NOSQL:支援，並且由於資料間沒有關聯性，NOSQL 能更好的運作在分散式系統。&lt;/p&gt;
&lt;h3 id=&#34;寫入&#34;&gt;寫入
&lt;/h3&gt;&lt;p&gt;SQL:為了保持ACID，當在處理高併發的大量寫入請求時會消耗更多資源並影響效能。&lt;/p&gt;
&lt;p&gt;NOSQL:NOSQL 在處理高併發的大量寫入請求時，表現會比 SQL 來的好，原因是因為 NOSQL 的資料在寫入時不必立刻同步到所有 server，而是最終資料一致就好。&lt;/p&gt;
&lt;h3 id=&#34;查詢&#34;&gt;查詢
&lt;/h3&gt;&lt;p&gt;SQL:SQL 擅長處理複雜的查詢，特別是涉及多表 Join 以及複雜的過濾條件時。&lt;/p&gt;
&lt;p&gt;NOSQL: 單一紀錄的查詢快，但是複雜的查詢，特別是涉及多表的查詢會相較 SQL 慢。&lt;/p&gt;
&lt;h3 id=&#34;結論&#34;&gt;結論
&lt;/h3&gt;&lt;p&gt;SQL:適合需要 ACID 來保證資料正確，複雜查詢的應用。&lt;/p&gt;
&lt;p&gt;NOSQL:適合高效能寫入，需要在分散式系統運作，可接受最終一致性的應用。&lt;/p&gt;
&lt;h2 id=&#34;補充&#34;&gt;補充
&lt;/h2&gt;&lt;h3 id=&#34;isolation-level&#34;&gt;isolation level
&lt;/h3&gt;&lt;p&gt;isolation 分成 四個 level，分別是為了解決不同狀況的需求。&lt;/p&gt;
&lt;p&gt;先解釋資料庫在儲存時會遇到那些狀況。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Dirty Read : 一個交易向資料庫寫入資料時，還沒 commit，另一個交易卻讀取了尚未 commit 的資料
&lt;ul&gt;
&lt;li&gt;A 交易在一次交易中讀取了兩次資料，但是在第一次資料讀取跟第二次資料讀取之間，B交易將資料改寫了，導致兩次讀取資料的數值不同。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Non-repeatable reads : 同一個交易中讀取了多次資料，但是卻取得了不同的結果
&lt;ul&gt;
&lt;li&gt;A 交易在一次交易中讀取了多次資料，但是在資料讀取間，B交易改寫了資料並 commit，導致了A讀取了相同資料卻取得不同結果。&lt;/li&gt;
&lt;li&gt;Dirty Read 也屬於 Non-repeatable reads 差別在於有沒有 commit&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Phantom reads: 當在同一個交易中，連續讀取資料取得的比數卻不同。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;為了解決這些狀況，於是將 isolation 分成 4 個 level&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Read Uncommited : 可以讀取為 commit 的資料。&lt;/li&gt;
&lt;li&gt;Read Commited: 只能讀取到已 commit 的資料，解決 Dirty Read。&lt;/li&gt;
&lt;li&gt;Repeatable Read: 同一交易中，只要搜尋條件相同，便能取得相同結果，解決 Non-repeatable reads。&lt;/li&gt;
&lt;li&gt;Serializable: 多個 transaction 執行時，只要順序相同，得到的結果便相同，但是因為資料庫會確保 transaction 依序完成，會造成效能降低，解決 Phantom reads。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;參考&#34;&gt;參考:
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://medium.com/appdev-ooops/%E8%B3%87%E6%96%99%E5%BA%AB-%E4%BD%A0%E7%9C%9F%E7%9A%84%E7%94%A8%E5%B0%8D%E4%BA%86%E5%97%8E-sql-vs-nosql-9621a05180d4&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://medium.com/appdev-ooops/%E8%B3%87%E6%96%99%E5%BA%AB-%E4%BD%A0%E7%9C%9F%E7%9A%84%E7%94%A8%E5%B0%8D%E4%BA%86%E5%97%8E-sql-vs-nosql-9621a05180d4&lt;/a&gt;
&lt;a class=&#34;link&#34; href=&#34;https://www.codegym.tech/blog/sql-vs-nosql&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.codegym.tech/blog/sql-vs-nosql&lt;/a&gt;
&lt;a class=&#34;link&#34; href=&#34;https://realnewbie.com/basic-concent/database/sql-vs-nosql-differences-beginner-guide/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://realnewbie.com/basic-concent/database/sql-vs-nosql-differences-beginner-guide/&lt;/a&gt;
&lt;a class=&#34;link&#34; href=&#34;https://oldmo860617.medium.com/%E5%88%9D%E6%AD%A5%E8%AA%8D%E8%AD%98%E5%88%86%E6%95%A3%E5%BC%8F%E8%B3%87%E6%96%99%E5%BA%AB%E8%88%87-nosql-cap-%E7%90%86%E8%AB%96-a02d377938d1&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://oldmo860617.medium.com/%E5%88%9D%E6%AD%A5%E8%AA%8D%E8%AD%98%E5%88%86%E6%95%A3%E5%BC%8F%E8%B3%87%E6%96%99%E5%BA%AB%E8%88%87-nosql-cap-%E7%90%86%E8%AB%96-a02d377938d1&lt;/a&gt;
&lt;a class=&#34;link&#34; href=&#34;https://www.mysql.tw/2024/05/mysql-innodb-isolation-level.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.mysql.tw/2024/05/mysql-innodb-isolation-level.html&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Sqlalchemy</title>
        <link>https://example.com/post/sqlalchemy/</link>
        <pubDate>Tue, 13 May 2025 00:23:14 +0800</pubDate>
        
        <guid>https://example.com/post/sqlalchemy/</guid>
        <description>&lt;h2 id=&#34;前言&#34;&gt;前言
&lt;/h2&gt;&lt;p&gt;學到了 connection pool，想說要來 optimize 自己的 side project。&lt;/p&gt;
&lt;p&gt;沒想到研究了半天，原本使用的 Sqlalchemy 就已經有內建有做了。&lt;/p&gt;
&lt;p&gt;因此做個筆記紀錄一下，也給自己一個警惕，比起請 AI 直接開始改寫，不如先去讀一下官方文件，養成閱讀官方文件的習慣。&lt;/p&gt;
&lt;p&gt;在使用 AI 上也要更小心自己不夠了解的部分，避免被幻覺誤導。&lt;/p&gt;
&lt;h2 id=&#34;connection-pool&#34;&gt;Connection pool
&lt;/h2&gt;&lt;p&gt;每當跟資料庫要求 CRUD 操作時，都需要跟資料庫建立連線、進行操作、關閉連線。
建立連線跟關閉連線的動作對資料庫來說是很消耗資源的，connection pool 就是為了解決消耗資源的問題。&lt;/p&gt;
&lt;p&gt;connection pool 相當於連線的快取，程式會事先建立固定的連線數量，當要跟資料庫要求執行操作時，會從 connection pool 中取得已事先建立好的連線，完成操作後再歸還。&lt;/p&gt;
&lt;p&gt;透過重複使用已建立的連線，來減少每次操作都建立連線再關閉連線所消耗的資源。&lt;/p&gt;
&lt;p&gt;以下會先事先建立好資料庫，用於比較有 connection pool 跟沒有 connection pool
查詢的差異。&lt;/p&gt;
&lt;h2 id=&#34;mysqlconnector&#34;&gt;mysql.connector
&lt;/h2&gt;&lt;p&gt;mysql.connector 是由 MySQL 官方提供的 lib。
會先利用此 lib 的方法來連接資料庫做查詢。&lt;/p&gt;
&lt;p&gt;mysql.connector 的使用方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;透過 mysql.connector.connect 來設定基本設定以及建立連線，這裡不設定 port 是因為在測試範例中使用的是 mysql 的 default port 3306。&lt;/li&gt;
&lt;li&gt;透過 connection.cursor() 建立 cursor，透過 cursor 跟 DB 溝通(傳遞 SQL 指令跟取回結果)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;without_pool&#34;&gt;without_pool
&lt;/h3&gt;&lt;p&gt;每次查詢都會建立連線查詢，再關閉連線。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;def query_with_out_pool():
    connection = None
    cursor = None
    try:
        #建立連線
        connection = mysql.connector.connect(
            host=DB_HOST,
            user=DB_USER,
            passwd=DB_PASSWORD,
            database=DB_NAME
        )
        if connection.is_connected():
            cursor = connection.cursor()
            query = f&amp;#34;&amp;#34;&amp;#34;SELECT name 
            FROM {TABLE_NAME}
            WHERE name = &amp;#39;test_55&amp;#39;&amp;#34;&amp;#34;&amp;#34;
            cursor.execute(query)
            records = cursor.fetchall()
    except Error as e:
        print(f&amp;#34;Database operation error{e}&amp;#34;)
    finally:
        if connection and connection.is_connected():
            if cursor:
                cursor.close()
            connection.close()
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我使用 line_profile 來逐行檢視執行100次所消耗的資源。
會得到以下的輸出&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Wrote profile results to query.py.lprof
Timer unit: 1e-06 s

Total time: 2.9325 s
File: query.py
Function: query_with_out_pool at line 16

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    16                                           @profile
    17                                           def query_with_out_pool():
    18       100         56.4      0.6      0.0      connection = None
    19       100         24.8      0.2      0.0      cursor = None
    20       100         15.0      0.2      0.0      try:
    21       200    2733927.1  13669.6     93.2          connection = mysql.connector.connect(
    22       100         28.4      0.3      0.0              host=DB_HOST,
    23       100         21.5      0.2      0.0              user=DB_USER,
    24       100         17.5      0.2      0.0              passwd=DB_PASSWORD,
    25       100         25.9      0.3      0.0              database=DB_NAME
    26                                                   )
    27       100      29763.2    297.6      1.0          if connection.is_connected():
    28       100      31832.3    318.3      1.1              cursor = connection.cursor()
    29       200         99.7      0.5      0.0              query = f&amp;#34;&amp;#34;&amp;#34;SELECT name
    30       100         62.7      0.6      0.0              FROM {TABLE_NAME}
    31                                                       WHERE name = &amp;#39;test_55&amp;#39;&amp;#34;&amp;#34;&amp;#34;
    32       100      54132.4    541.3      1.8              cursor.execute(query)
    33       100       3652.7     36.5      0.1              records = cursor.fetchall()
    34                                               except Error as e:
    35                                                   print(f&amp;#34;Database operation error{e}&amp;#34;)
    36                                               finally:
    37       100      29637.8    296.4      1.0          if connection and connection.is_connected():
    38       100         59.0      0.6      0.0              if cursor:
    39       100        622.1      6.2      0.0                  cursor.close()
    40       100      48518.0    485.2      1.7              connection.close()

Total time: 2.9357 s
File: query.py
Function: test at line 84

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    84                                           @profile
    85                                           def test():
    86       101         51.7      0.5      0.0      for i in range(0,100):
    87       100    2935643.6  29356.4    100.0          query_with_out_pool()
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以發現有 93.2% 的時間都在建立連線。&lt;/p&gt;
&lt;h3 id=&#34;with_pool&#34;&gt;with_pool
&lt;/h3&gt;&lt;p&gt;mysql.connector 也有提供建立 pool 的方法，可以先建立連線，要使用連線的時候再從 pool 取。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#事先建立好連線
connection_pool = mysql.connector.pooling.MySQLConnectionPool(
            host=DB_HOST,
            user=DB_USER,
            passwd=DB_PASSWORD,
            database=DB_NAME,
            pool_size = 5,
        )

def query_with_pool():
    connection = connection_pool.get_connection()
    cursor = None
    try:
        if connection.is_connected():
            cursor = connection.cursor()
            query = f&amp;#34;&amp;#34;&amp;#34;SELECT name 
            FROM {TABLE_NAME}
            WHERE name = &amp;#39;test_55&amp;#39;&amp;#34;&amp;#34;&amp;#34;
            cursor.execute(query)
            records = cursor.fetchall()
    except Error as e:
        print(f&amp;#34;Database operation error{e}&amp;#34;)
    finally:
        if connection and connection.is_connected():
            if cursor:
                cursor.close()
            connection.close()
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;轉用 pool 後可以發現總消耗時間減少了，並且取用連線的時間也比建立連線短。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Wrote profile results to query.py.lprof
Timer unit: 1e-06 s

Total time: 0.212316 s
File: query.py
Function: query_with_pool at line 49

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    49                                           @profile
    50                                           def query_with_pool():
    51       100      21758.1    217.6     10.2      connection = connection_pool.get_connection()
    52       100         32.5      0.3      0.0      cursor = None
    53       100         15.4      0.2      0.0      try:
    54       100      19519.5    195.2      9.2          if connection.is_connected():
    55       100      21222.9    212.2     10.0              cursor = connection.cursor()
    56       200         86.4      0.4      0.0              query = f&amp;#34;&amp;#34;&amp;#34;SELECT name
    57       100         40.6      0.4      0.0              FROM {TABLE_NAME}
    58                                                       WHERE name = &amp;#39;test_55&amp;#39;&amp;#34;&amp;#34;&amp;#34;
    59       100      40642.8    406.4     19.1              cursor.execute(query)
    60       100       2980.9     29.8      1.4              records = cursor.fetchall()
    61                                               except Error as e:
    62                                                   print(f&amp;#34;Database operation error{e}&amp;#34;)
    63                                               finally:
    64       100      19098.2    191.0      9.0          if connection and connection.is_connected():
    65       100         54.1      0.5      0.0              if cursor:
    66       100        522.8      5.2      0.2                  cursor.close()
    67       100      86341.6    863.4     40.7              connection.close()

Total time: 0.214138 s
File: query.py
Function: test at line 84

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    84                                           @profile
    85                                           def test():
    86       101         35.0      0.3      0.0      for i in range(0,100):
    87       100     214103.5   2141.0    100.0          query_with_pool()
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;sqlalchemy&#34;&gt;sqlalchemy
&lt;/h2&gt;&lt;p&gt;sqlalchemy 是一個 ORM (Object Relational Mapper) library，讓使用者透過物件導向的方式去編寫程式碼，ORM 會再轉譯成 SQL 指令去執行。&lt;/p&gt;
&lt;p&gt;ORM 可以防止 SQL 注入攻擊，但由於轉譯的關係，使用 ORM 也會比原生的 SQL 速度要更慢。&lt;/p&gt;
&lt;p&gt;sqlalchemy default 就有 connection pool。&lt;/p&gt;
&lt;p&gt;以下是一個簡單的 sqlalchemy 範例&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;from sqlalchemy import Column, Integer, String,create_engine
from sqlalchemy.orm import declarative_base
from sqlalchemy.orm import sessionmaker

#建立一個 engine 透過 pymysql 驅動連線
engine = create_engine(f&amp;#34;mysql+pymysql://{DB_USER}:{DB_PASSWORD}@{DB_HOST}:{3306}/{DB_NAME}&amp;#34;)

# 建立一個 ORM 的基礎類別，所有資料表對應的類別都要繼承這個 Base
Base = declarative_base()

# 建立一個 Session 類別，用來建立與資料庫互動的 session（會話）
Session = sessionmaker(bind=engine)

# 定義一個 ORM 類別 User，對應資料庫中的 &amp;#39;test_member&amp;#39; 資料表
class User(Base):
    __tablename__ = &amp;#39;test_member&amp;#39;

    id = Column(Integer, primary_key=True, autoincrement=True)
    name = Column(String(255),nullable=False)

def query_with_pool_sqlalchemy() -&amp;gt; User|None:

        # 建立一個資料庫會話
        session = Session()
        query_user = session.query(User).filter(User.name == &amp;#34;test_55&amp;#34;).first()

        # 關閉 session（釋放資源）
        session.close()
        return query_user
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;sqlalchemy 在使用 pool 的方式比較不同，並非是預先建立好連線。&lt;/p&gt;
&lt;p&gt;而是首次使用的時候才建立連線，而 session.close 則是將資源歸還給 pool，並非關閉連線。&lt;/p&gt;
&lt;p&gt;可以發現使用 sqlalchemy 的時間與 mysql.connector 使用 pool 的時間接近，但稍慢一點，這部分的差異可能就是在於轉譯 SQL 指令所花費的時間。&lt;/p&gt;
&lt;p&gt;可以發現 63.3% 的時間都在 query_uesr 設定 fliter 條件去搜尋這段。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Wrote profile results to query.py.lprof
Timer unit: 1e-06 s

Total time: 0.229665 s
File: query.py
Function: query_with_pool_sqlalchemy at line 78

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    78                                           @profile
    79                                           def query_with_pool_sqlalchemy() -&amp;gt; User|None:
    80       100       3421.0     34.2      1.5          session = Session()
    81       100     145461.8   1454.6     63.3          query_user = session.query(User).filter(User.name == &amp;#34;test_55&amp;#34;).first()
    82       100      80724.5    807.2     35.1          session.close()
    83       100         57.7      0.6      0.0          return query_user

Total time: 0.231337 s
File: query.py
Function: test at line 84

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    84                                           @profile
    85                                           def test():
    86       101         29.0      0.3      0.0      for i in range(0,100):
    87       100     231308.2   2313.1    100.0          query_with_pool_sqlalchemy()
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;sqlalchemy 雖然在預設就有使用 pool，但也有提供使用者自行設定 pool 的參數。
* pool_size    : pool 內有多少連線需要保持
* max_overflow : 設定 pool 中最多可以有多少連線
* pool_recycle : 設定多少秒後回收連線
* pool_timeout : 設定多少秒後放棄從 pool 中取得連線
max_overflow 的用意是當連線都在被使用的時候，最多可以多開到多少連線。
以下是使用例子，作為 &lt;code&gt;create_engine&lt;/code&gt; 的參數傳入即可。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;engine = create_engine(f&amp;#34;mysql+pymysql://{DB_USER}:{DB_PASSWORD}@{DB_HOST}:{3306}/{DB_NAME},pool_size=5, max_overflow=10&amp;#34;)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;更詳細的使用設定可以參考&lt;a class=&#34;link&#34; href=&#34;https://docs.sqlalchemy.org/en/20/core/engines.html#sqlalchemy.create_engine&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;官方文件&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;reference&#34;&gt;Reference
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://en.wikipedia.org/wiki/Connection_pool&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://en.wikipedia.org/wiki/Connection_pool&lt;/a&gt;
&lt;a class=&#34;link&#34; href=&#34;https://vocus.cc/article/5f800406fd89780001365d17&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://vocus.cc/article/5f800406fd89780001365d17&lt;/a&gt;
&lt;a class=&#34;link&#34; href=&#34;https://dev.mysql.com/doc/connector-python/en/connector-python-example-cursor-select.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://dev.mysql.com/doc/connector-python/en/connector-python-example-cursor-select.html&lt;/a&gt;
&lt;a class=&#34;link&#34; href=&#34;https://www.runoob.com/python3/python-mysql-connector.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.runoob.com/python3/python-mysql-connector.html&lt;/a&gt;
&lt;a class=&#34;link&#34; href=&#34;https://dev.mysql.com/doc/connector-python/en/connector-python-connection-pooling.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://dev.mysql.com/doc/connector-python/en/connector-python-connection-pooling.html&lt;/a&gt;
&lt;a class=&#34;link&#34; href=&#34;https://github.com/pyutils/line_profiler&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/pyutils/line_profiler&lt;/a&gt;
&lt;a class=&#34;link&#34; href=&#34;https://reginapanpan.medium.com/sqlalchemy-%E6%98%AF%E4%BB%80%E9%BA%BC-%E8%88%87-orm-%E7%9A%84%E9%97%9C%E4%BF%82-a57b16053aec&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://reginapanpan.medium.com/sqlalchemy-%E6%98%AF%E4%BB%80%E9%BA%BC-%E8%88%87-orm-%E7%9A%84%E9%97%9C%E4%BF%82-a57b16053aec&lt;/a&gt;
&lt;a class=&#34;link&#34; href=&#34;https://www.explainthis.io/zh-hant/swe/orm-intro&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.explainthis.io/zh-hant/swe/orm-intro&lt;/a&gt;
&lt;a class=&#34;link&#34; href=&#34;https://docs.sqlalchemy.org/en/20/core/pooling.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://docs.sqlalchemy.org/en/20/core/pooling.html&lt;/a&gt;
&lt;a class=&#34;link&#34; href=&#34;https://docs.sqlalchemy.org/en/20/core/engines.html#sqlalchemy.create_engine&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://docs.sqlalchemy.org/en/20/core/engines.html#sqlalchemy.create_engine&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Design Pattern Factory</title>
        <link>https://example.com/post/design-pattern-factory/</link>
        <pubDate>Fri, 09 May 2025 17:11:07 +0800</pubDate>
        
        <guid>https://example.com/post/design-pattern-factory/</guid>
        <description>&lt;h2 id=&#34;工廠模式&#34;&gt;工廠模式
&lt;/h2&gt;&lt;p&gt;封裝建立物件的邏輯，讓使用者無須在意物件創建的相關邏輯(e.g. 讀取設定檔&amp;hellip;)。&lt;/p&gt;
&lt;p&gt;在工廠模式中，會將封裝建立物件邏輯的類別稱為工廠，而實際建立的物件稱為產品，就像普通人並不會知道工廠運作的邏輯，但知道工廠生產什麼產品一樣。
工廠模式的目的是讓使用者(需要物件的function或邏輯)，無需在意這些物件建立的相關邏輯。&lt;/p&gt;
&lt;p&gt;以下會以漫畫(comic)作為產品 來舉例說明，假設我有兩種漫畫，分別是 funny 跟 adventure。
我想要取得漫畫物件最簡單的方法是透過 if 來判斷該創立哪種物件。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;from abc import ABC, abstractmethod
class Book(ABC):
    @abstractmethod
    def content(self) -&amp;gt; str:
        pass
    @abstractmethod
    def cost(self) -&amp;gt; int:
        pass

class FunnyComics(Book):
    def content(self) -&amp;gt; str:
        return &amp;#39;This is funny comic&amp;#39;
    def cost(self) -&amp;gt; int:
        return 4
class AdventureComics(Book):
    def content(self) -&amp;gt; str:
        return &amp;#39;This is adventure comic&amp;#39;
    def cost(self) -&amp;gt; int:
        return 3

def buy_book(book_type:str) -&amp;gt; Book:
    if book_type == &amp;#34;Funny Comic&amp;#34;:
        book = FunnyComics()
    elif book_type == &amp;#34;Adventure Comic&amp;#34;:
        book = AdventureComics()
    print(book.content())
    print(book.cost())

if __name__ == &amp;#39;__main__&amp;#39;:
    buy_book(&amp;#34;Funny Comic&amp;#34;)
    buy_book(&amp;#34;Adventure Comic&amp;#34;)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但是會發現當漫畫的種類越來越多的時候，&lt;code&gt;buy_book&lt;/code&gt; 內的邏輯會越來越多，並且會一直需要改動 &lt;code&gt;buy_book&lt;/code&gt; 這個 &lt;code&gt;function&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;簡單工廠&#34;&gt;簡單工廠
&lt;/h3&gt;&lt;p&gt;所有的產品物件類別都由一個共同的工廠類別或介面來管理。&lt;/p&gt;
&lt;p&gt;其實是將 if 等相關判斷式另外包進去一個類別做管理&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;class SimpleBookFactory():
    def create_book(self,book_type:str) -&amp;gt; Book:
        if book_type == &amp;#34;Funny Comic&amp;#34;:
            book = FunnyComics()
        elif book_type == &amp;#34;Adventure Comic&amp;#34;:
            book = AdventureComics()
        return book

def buy_book(book_type:str):
    book_factory = SimpleBookFactory()
    book = book_factory.create_book(book_type)
    print(book.content())
    print(book.cost())
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;這樣做的好處在於對於 &lt;code&gt;buy_book&lt;/code&gt; 來說，不用在意 &lt;code&gt;FunnyComics&lt;/code&gt; 跟 &lt;code&gt;AdventureComics&lt;/code&gt; 這兩個類別的實作細節。&lt;/p&gt;
&lt;p&gt;只需透過傳遞參數給 &lt;code&gt;SimpleBookFactory&lt;/code&gt; 即可。&lt;/p&gt;
&lt;p&gt;但是這樣做依然有當新增類別時需要修改到 &lt;code&gt;SimpleBookFactory&lt;/code&gt; 這個問題。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;from abc import ABC, abstractmethod
class Book(ABC):
    @abstractmethod
    def content(self) -&amp;gt; str:
        pass
    @abstractmethod
    def cost(self) -&amp;gt; int:
        pass

class FunnyComics(Book):
    def content(self) -&amp;gt; str:
        return &amp;#39;This is funny comic&amp;#39;
    def cost(self) -&amp;gt; int:
        return 4
class AdventureComics(Book):
    def content(self) -&amp;gt; str:
        return &amp;#39;This is adventure comic&amp;#39;
    def cost(self) -&amp;gt; int:
        return 3

class SimpleBookFactory():
    def create_book(self,book_type:str)-&amp;gt; Book:
        if book_type == &amp;#34;Funny Comic&amp;#34;:
            book = FunnyComics()
        elif book_type == &amp;#34;Adventure Comic&amp;#34;:
            book = AdventureComics()
        return book
    
def buy_book(book_type:str):
    book_factory = SimpleBookFactory()
    book = book_factory.create_book(book_type)
    print(book.content())
    print(book.cost())

if __name__ == &amp;#39;__main__&amp;#39;:
    buy_book(&amp;#39;Funny Comic&amp;#39;)
    buy_book(&amp;#39;Adventure Comic&amp;#39;)
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;工廠方法&#34;&gt;工廠方法
&lt;/h3&gt;&lt;p&gt;設計工廠介面，產生產品物件由根據工廠介面建立的子類別來管理。&lt;/p&gt;
&lt;p&gt;首先先來將簡單工廠的設計轉為工廠模式的設計。&lt;/p&gt;
&lt;p&gt;先定義一個工廠類別的介面，並且都應該返回一個產品類別的物件。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;class BookFactory(ABC):
    @abstractmethod
    def create_book(self) -&amp;gt; Book:
        pass
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;根據這個介面，來修改原本的 &lt;code&gt;buy_book&lt;/code&gt;，對於 &lt;code&gt;buy_book&lt;/code&gt; 來說，只需知道傳遞進來的參數是 &lt;code&gt;BookFactory&lt;/code&gt; 類別即可。&lt;/p&gt;
&lt;p&gt;所以除非是更改到了 &lt;code&gt;BookFactory&lt;/code&gt; 這個介面，否則不會因為新增了工廠或是產品類別而需要更改到 &lt;code&gt;buy_book&lt;/code&gt;。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;def buy_book(factory:BookFactory):
    book_factory = factory()
    book = book_factory.create_book()
    print(book.content())
    print(book.cost())
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;接著設計工廠類別&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;class FunnyBookFactory(BookFactory):
    def create_book(self)-&amp;gt; Book:
        return FunnyComics()

class AdventureBookFactory(BookFactory):
    def create_book(self)-&amp;gt; Book:
        return AdventureComics()
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;相對於簡單工場類別，假設我今天需要新增一個新的 &lt;code&gt;Book&lt;/code&gt; 類型，我只須新增一個工廠類別與產品類別就可以。&lt;/p&gt;
&lt;p&gt;不必擔心新增了 &lt;code&gt;Book&lt;/code&gt; 類型需要去改動到原本的工廠類別，不像簡單工場新增一個產品就需要更改到  &lt;code&gt;SimpleBookFactory&lt;/code&gt; 類別。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;buy_book&lt;/code&gt; 一樣不用在意如何去建立產品物件，因為這些都由各自對應的工廠負責。&lt;/p&gt;
&lt;p&gt;e.g. 假設要新增一個 love comic，只需新增如下&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;class LoveComics(Book):
    def content(self) -&amp;gt; str:
        return &amp;#39;This is love comic&amp;#39;
    def cost(self) -&amp;gt; int:
        return 6

class LoveComicsFactory(BookFactory):
    def create_book(self)-&amp;gt; Book:
        return LoveComics()
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;不會更改到 &lt;code&gt;buy_book&lt;/code&gt;，甚至先前建立的 &lt;code&gt;FunnyComicsFactory&lt;/code&gt; 或是 &lt;code&gt;AdventureComicsFactory&lt;/code&gt; 類別。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;from abc import ABC, abstractmethod
class Book(ABC):
    @abstractmethod
    def content(self) -&amp;gt; str:
        pass
    @abstractmethod
    def cost(self) -&amp;gt; int:
        pass

class FunnyComics(Book):
    def content(self) -&amp;gt; str:
        return &amp;#39;This is funny comic&amp;#39;
    def cost(self) -&amp;gt; int:
        return 4
    
class AdventureComics(Book):
    def content(self) -&amp;gt; str:
        return &amp;#39;This is adventure comic&amp;#39;
    def cost(self) -&amp;gt; int:
        return 3
    
class LoveComics(Book):
    def content(self) -&amp;gt; str:
        return &amp;#39;This is love comic&amp;#39;
    def cost(self) -&amp;gt; int:
        return 6
    
class BookFactory(ABC):
    @abstractmethod
    def create_book(self,book_type:str) -&amp;gt; Book:
        pass

class FunnyBookFactory(BookFactory):
    def create_book(self)-&amp;gt; Book:
        return FunnyComics()

class AdventureBookFactory(BookFactory):
    def create_book(self)-&amp;gt; Book:
        return AdventureComics()
    
class LoveBookFactory(BookFactory):
    def create_book(self)-&amp;gt; Book:
        return LoveComics()

def buy_book(factory:BookFactory):
    book_factory = factory()
    book = book_factory.create_book()
    print(book.content())
    print(book.cost())

if __name__ == &amp;#39;__main__&amp;#39;:
    buy_book(FunnyBookFactory)

    buy_book(AdventureBookFactory)

    buy_book(LoveBookFactory)
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;抽象工廠&#34;&gt;抽象工廠
&lt;/h3&gt;&lt;p&gt;設計工廠介面用於建立一系列相關的產品。&lt;/p&gt;
&lt;p&gt;假設當類別變多了，例如今天每種書又都分為電子書跟實體書，前面使用的工廠方法所需設計的類別就可能會變很多。&lt;/p&gt;
&lt;p&gt;這時就可以使用抽象工廠來解決這個問題。&lt;/p&gt;
&lt;p&gt;先設計抽象類別，每個工廠會分別建立實體書跟電子書。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;class BookFactory(ABC):
    @abstractmethod
    def create_book()-&amp;gt; Book:
        pass
    @abstractmethod
    def create_e_book()-&amp;gt; Book:
        pass
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;擴充電子書產品類別(&lt;code&gt;Book&lt;/code&gt;)&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;class FunnyComicsEBook(Book):
    def content(self) -&amp;gt; str:
        return &amp;#39;This is funny comic e-book&amp;#39;
    def cost(self) -&amp;gt; int:
        return 3
class AdventureComicsEBook(Book):
    def content(self) -&amp;gt; str:
        return &amp;#39;This is adventure comic e-book&amp;#39;
    def cost(self) -&amp;gt; int:
        return 2
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;根據 &lt;code&gt;BookFactory&lt;/code&gt; 設計子類別&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;class FunnyBookFactory(BookFactory):
    def create_book(self)-&amp;gt; Book:
        return FunnyComics()
    def create_e_book(self)-&amp;gt; Book:
        return FunnyComicsEBook()

class AdventureBookFactory(BookFactory):
    def create_book(self)-&amp;gt; Book:
        return AdventureComics()
    def create_e_book(self)-&amp;gt; Book:
        return AdventureComicsEBook()
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;from abc import ABC, abstractmethod

class Book(ABC):
    @abstractmethod
    def content(self) -&amp;gt; str:
        pass
    @abstractmethod
    def cost(self) -&amp;gt; int:
        pass

class FunnyComics(Book):
    def content(self) -&amp;gt; str:
        return &amp;#39;This is funny comic&amp;#39;
    def cost(self) -&amp;gt; int:
        return 4
    
class FunnyComicsEBook(Book):
    def content(self) -&amp;gt; str:
        return &amp;#39;This is funny comic e-book&amp;#39;
    def cost(self) -&amp;gt; int:
        return 3
    
class AdventureComics(Book):
    def content(self) -&amp;gt; str:
        return &amp;#39;This is adventure comic&amp;#39;
    def cost(self) -&amp;gt; int:
        return 3

class AdventureComicsEBook(Book):
    def content(self) -&amp;gt; str:
        return &amp;#39;This is adventure comic e-book&amp;#39;
    def cost(self) -&amp;gt; int:
        return 2

class BookFactory(ABC):
    @abstractmethod
    def create_book() -&amp;gt; Book:
        pass
    @abstractmethod
    def create_e_book()-&amp;gt; Book:
        pass

class FunnyBookFactory(BookFactory):
    def create_book(self)-&amp;gt; Book:
        return FunnyComics()
    def create_e_book(self)-&amp;gt; Book:
        return FunnyComicsEBook()

class AdventureBookFactory(BookFactory):
    def create_book(self)-&amp;gt; Book:
        return AdventureComics()
    def create_e_book(self)-&amp;gt; Book:
        return AdventureComicsEBook()

def buy_book(factory:BookFactory):
    book_factory = factory()
    book = book_factory.create_book()
    print(book.content())
    print(book.cost())
    e_book = book_factory.create_e_book()
    print(e_book.content())
    print(e_book.cost())

if __name__ == &amp;#39;__main__&amp;#39;:
    buy_book(FunnyBookFactory)

    buy_book(AdventureBookFactory)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;相對於工廠方法，抽象工廠其實更注重於產出彼此相關的產品。
工廠方法則是專門產生一個產品的工廠。&lt;/p&gt;
&lt;p&gt;雖然不同的抽象工廠可能生產的產品具備相同功能，但它們的具體實作會根據工廠有所不同。&lt;/p&gt;
&lt;p&gt;例如本篇例子&lt;code&gt;FunnyBookFactory&lt;/code&gt; 跟 &lt;code&gt;AdventureBookFactory&lt;/code&gt; 底下的產品都分成實體書跟電子書。
但是 &lt;code&gt;content&lt;/code&gt; 會根據是  &lt;code&gt;FunnyBookFactory&lt;/code&gt; 還是 &lt;code&gt;AdventureBookFactory&lt;/code&gt; 而不同。&lt;/p&gt;
&lt;h2 id=&#34;參考&#34;&gt;參考:
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;深入淺出設計模式&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://skyyen999.gitbooks.io/-study-design-pattern-in-java/content/simpleFactory.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://skyyen999.gitbooks.io/-study-design-pattern-in-java/content/simpleFactory.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>Design Pattern Strategy</title>
        <link>https://example.com/post/design-pattern-strategy/</link>
        <pubDate>Fri, 09 May 2025 11:28:40 +0800</pubDate>
        
        <guid>https://example.com/post/design-pattern-strategy/</guid>
        <description>&lt;h2 id=&#34;策略模式&#34;&gt;策略模式
&lt;/h2&gt;&lt;p&gt;將可互換的演算法封裝為獨立的類別，透過統一介面使用類別，使得變更行為時，不必因行為變化而重新修改類別本身。&lt;/p&gt;
&lt;p&gt;以 python 舉個例子，假設我今天有個旅遊類別如下。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;class Travel():
    def hotel(self):
        print(&amp;#39;Staying at the Taiwan Hotel.&amp;#39;)
    def transport(self,distance:int):
        print(f&amp;#34;Walk for {distance / 1} minutes.&amp;#34;)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但是我目前有個需求是要新增一個新的交通方式:&amp;ldquo;開車&amp;rdquo;，他的時間計算跟原本的走路的計算方式不一樣。
那這時我們可以選擇:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;繼承 Travel 類別，並複寫 transport function。
&lt;ul&gt;
&lt;li&gt;需要為此撰寫一個新的類別，假設 hotel 不一樣也會需要複寫，當有幾種 hotel 跟幾種 transport 的組合，就需要寫多少類別，在維護上會是一大難題。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;直接修改 transport
&lt;ul&gt;
&lt;li&gt;透過參數來選擇使用哪種交通工具，但是會需要確認是否影響了既有功能，當功能是複雜功能時有可能造成無法預期的錯誤。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一開始使用策略模式設計類別就可以避免以上兩者的缺點，我們可以將 transport 會需要作的內容定義為介面。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;from abc import ABC,abstractmethod

class TransportStrategy(ABC):
    @abstractmethod
    def transport(self,distance:int):
        pass
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;定義了每個 transport 都該有的行為後，就可以設計類別會直接執行行為而不用顧慮是哪種 transport。
可以重新定義類別為&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;class Travel():
    def __init__(self,transport_strategy:TransportStrategy):
        self.transport_handler = transport_strategy()
    def hotel(self):
        print(&amp;#39;Staying at the Taiwan Hotel.&amp;#39;)
    def transport(self,distance:int):
        self.transport_handler.transport(distance)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然後另外定義各種 TransportStrategy&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;class WorkTransport(TransportStrategy):
    def transport(self,distance:int):
        print(f&amp;#34;Walk for {distance / 1} minutes.&amp;#34;)

class DriveTransport(TransportStrategy):
    def transport(self,distance:int):
        print(f&amp;#34;Walk for {distance / 10} minutes.&amp;#34;)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;這樣只需要在創建 Travel 類別的物件時，指定 TransportStrategy 就好，更甚至可以另外定義 function 去動態的修改 TransportStrategy。
可以在某些條件下從 work_transport 變為 drive_transport。
這樣子可以解決:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不必為了多種組合而去建立類別。&lt;/li&gt;
&lt;li&gt;每個 TransportStrategy 都是獨立的，當我要新增新的 TransportStrategy 並不會影響到原有的 TransportStrategy 的程式碼。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;from abc import ABC,abstractmethod

class TransportStrategy(ABC):
    @abstractmethod
    def transport(self,distance:int):
        pass
class WorkTransport(TransportStrategy):
    def transport(self,distance:int):
        print(f&amp;#34;Walk for {distance / 1} minutes.&amp;#34;)

class DriveTransport(TransportStrategy):
    def transport(self,distance:int):
        print(f&amp;#34;Walk for {distance / 10} minutes.&amp;#34;)

class Travel():
    def __init__(self,transport_strategy:TransportStrategy):
        self.transport_handler = transport_strategy()
    def hotel(self):
        print(&amp;#39;Staying at the Taiwan Hotel.&amp;#39;)
    def transport(self,distance:int):
        self.transport_handler.transport(distance)

if __name__ == &amp;#39;__main__&amp;#39;:
    travel_handler = Travel(WorkTransport)
    travel_handler.transport(10)
    travel_handler = Travel(DriveTransport)
    travel_handler.transport(10)
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;參考&#34;&gt;參考:
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;深入淺出設計模式&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://medium.com/bucketing/behavioral-patterns-strategy-pattern-483d074d046a&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://medium.com/bucketing/behavioral-patterns-strategy-pattern-483d074d046a&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://medium.com/%E4%BA%BA%E7%94%9F%E7%9A%84%E5%90%84%E7%A8%AE%E5%8F%AF%E8%83%BD/%E6%B7%B1%E5%85%A5%E6%B7%BA%E5%87%BA%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%BC%8F-design-pattern-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F-1-strategy-pattern-8029f46659ef&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://medium.com/%E4%BA%BA%E7%94%9F%E7%9A%84%E5%90%84%E7%A8%AE%E5%8F%AF%E8%83%BD/%E6%B7%B1%E5%85%A5%E6%B7%BA%E5%87%BA%E8%A8%AD%E8%A8%88%E6%A8%A1%E5%BC%8F-design-pattern-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F-1-strategy-pattern-8029f46659ef&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>Leetcode 53</title>
        <link>https://example.com/post/leetcode-53/</link>
        <pubDate>Wed, 07 May 2025 16:46:07 +0800</pubDate>
        
        <guid>https://example.com/post/leetcode-53/</guid>
        <description>&lt;h2 id=&#34;題目&#34;&gt;題目
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode.com/problems/maximum-subarray/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;53. Maximum Subarray&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;給予一個數字陣列 nums, 找到該陣列的子集合中，相加最大的合，並且回傳合。&lt;/p&gt;
&lt;h2 id=&#34;pseudocode&#34;&gt;Pseudocode
&lt;/h2&gt;&lt;p&gt;這題我一開始的想法是應該是 DP 相關題目，直接暴力O(N^2)解會超時。
我的思路是在計算和的時候，要想辦法沿用先前的計算。
最大和的值，從 nums 的第0個元素開始，因為只有一個元素也是子集合。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;初始化 max_answer 為 nums[0] 用來記錄最大和
初始化 temp = 0 用來記錄當前的和

#以下用 max(A,B) 表示 A,B 中取較大者
從第 0 個 元素開始逐一遍歷 nums:
    當 temp + 元素 大於 max_answer:
        # 當元素比 temp + 元素還大的時候，就應該要從元素開始計算了。
        temp = max(元素,temp + 元素)
        max_answer = temp
    否則:
        temp = max(元素,temp + 元素)
        max_answer = max(max_answer,num)
#確認到最後一個元素的連續和有沒有比目前的答案還大
max_answer = max(temp,max_answer)

回傳 max_answer
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其實我第一版的思路有一些重複計算的地方，因為我最開始的思路是&lt;code&gt;當 temp + 元素 大於 max_answer&lt;/code&gt; 時，應該要重置 temp，所以以上 Pseudocode 的內容是邊 debug 得出的。
仔細想可以發現，其實無論如何當 temp + 元素比元素本身還要小的時候，就不該繼續計算合了。&lt;/p&gt;
&lt;p&gt;舉以下兩個例子&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;目前迴圈都走到 index = 1

[4,-1,2,1]
4 + -1 &amp;gt; -1
所以繼續計算下去 3 比從 -1 開始從頭計算還要大

[-5,1,6,2]
-5 + 1 &amp;lt; 1
所以繼續計算下去 -4 比從 1 開始從頭計算還要小
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;而 max answer 在每次更新 temp 時確認是否有比較大就好，所以可以將程式碼簡化為&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;初始化 max_answer 為 nums[0] 用來記錄最大和
初始化 temp = 0 用來記錄當前的和

#以下用 max(A,B) 表示 A,B 中取較大者
從第 0 個 元素開始逐一遍歷 nums:
    temp = max(元素,temp + 元素)
    max_answer = max(max_answer,num)

回傳 max_answer
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;時間複雜度一樣是 O(N)，但後者的程式碼意義應該更為清楚。&lt;/p&gt;
&lt;h2 id=&#34;python&#34;&gt;Python
&lt;/h2&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;class Solution:
    def maxSubArray(self, nums: List[int]) -&amp;gt; int:
        max_answer = nums[0]
        temp = 0
        for num in nums:
            temp = max(num,temp + num)
            max_answer = max(max_answer,temp)
        return max_answer
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;go&#34;&gt;Go
&lt;/h2&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func max(A,B int)int {
    if (A &amp;gt; B){
        return A
    }
    return B
}
func maxSubArray(nums []int) int {
    max_answer := nums[0]
    temp := 0
    for index := 0 ; index &amp;lt; len(nums) ; index ++{
        temp = max(nums[index],temp + nums[index])
        max_answer = max(max_answer,temp)
    }
    return max_answer
}
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>Leetcode 347</title>
        <link>https://example.com/post/leetcode-347/</link>
        <pubDate>Tue, 06 May 2025 21:07:33 +0800</pubDate>
        
        <guid>https://example.com/post/leetcode-347/</guid>
        <description>&lt;h2 id=&#34;題目&#34;&gt;題目
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode.com/problems/top-k-frequent-elements&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;347. Top K Frequent Elements&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;給予一個數字陣列 nums 跟數字 k ，回傳這個數字陣列中出現的數字頻率前 K 多的數字。
題目有保證 answer 是 unique ， 所以我認為不用考慮到頻率有相等，但剛好在第 K 跟第 K + 1 的狀況。&lt;/p&gt;
&lt;h2 id=&#34;pseudocode&#34;&gt;Pseudocode
&lt;/h2&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;初始化一個 frequency map 用來記錄元素出現頻率
從第 0 個元素開始遍歷 nums:
    如果元素沒有出現過:
        將元素作為 key 在 frequency 中對應 0
    將 frequency 中的元素對應的 value + 1，紀錄出現頻率 + 1 
根據 frequency 內的 value 去排序對應的 key 出現頻率的多寡
將排序結果中前 K 大的 key 回傳
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;時間複雜度會根據排序的演算法而有不同，如果是 Python 的 sorted 或 go 的 sort是O(n log n)&lt;/p&gt;
&lt;h2 id=&#34;python&#34;&gt;Python
&lt;/h2&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;class Solution:
    def topKFrequent(self, nums: List[int], k: int) -&amp;gt; List[int]:
        frequency = {}
        for num in nums:
            if num not in frequency:
                frequency[num] = 0
            frequency[num] += 1
        
        answer = sorted(frequency.keys(),key = lambda x: frequency[x],reverse=True)
        return answer[:k]
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;go&#34;&gt;Go
&lt;/h3&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;import (
    &amp;#34;fmt&amp;#34;
    &amp;#34;sort&amp;#34;
)

func topKFrequent(nums []int, k int) []int {
    frequency :=  map[int]int{}
    for index:=0;index &amp;lt; len(nums);index += 1{
        if _,ok := frequency[nums[index]]; !ok{
            frequency[nums[index]] = 0
        }
        frequency[nums[index]] += 1
    }
    answer := []int{}
    for number := range frequency{
        answer = append(answer,number)
    }

    sort.Slice(answer,func(i,j int) bool{
        return frequency[answer[i]] &amp;gt; frequency[answer[j]]
    })
    return answer[:k]
}
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>Leetcode 49</title>
        <link>https://example.com/post/leetcode-49/</link>
        <pubDate>Fri, 02 May 2025 14:37:32 +0800</pubDate>
        
        <guid>https://example.com/post/leetcode-49/</guid>
        <description>&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode.com/problems/group-anagrams&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;49. Group anagram&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;給予一個字串陣列，將相同的 angram 放在一個陣列中(為求方便，稱呼其為 angram 陣列)， 再將所有 angram 陣列放到一個陣列後回傳，可以以任何順序回傳。&lt;/p&gt;
&lt;h2 id=&#34;pseudocode---1&#34;&gt;Pseudocode - 1
&lt;/h2&gt;&lt;p&gt;此題跟 &lt;a class=&#34;link&#34; href=&#34;https://example.com/post/leetcode-242/&#34; &gt;leetcode-242&lt;/a&gt; 很像。
嘗試呼叫 &lt;a class=&#34;link&#34; href=&#34;https://example.com/post/leetcode-242/&#34; &gt;leetcode-242&lt;/a&gt; 的 isAnaragram 來解決這題。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;從第 0 個字串開始，逐一遍例輸入字串陣列的每一個字串：
    確認目前字串有無被確認為其他字串的 angram：
        跳下一個字串繼續
    從第一個迴圈取得的字串後的字串開始，逐一遍歷輸入字串陣列的每一個字串：
        確認取得的字串有無被確認為其他字串的 angram：
            跳下一個字串繼續
        確認取得字串是否是目前字串的 angram，是的話記錄下來
    將目前字串跟目前字串的 angram 都放入答案
回傳所有答案
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;時間複雜度: O(N^2)
這裡的時間複雜度不包含確認兩個字串是否是彼此的 angram。
假設 Ｌ 是字串長度的話（先不考慮所有字串的長度是否都相同為Ｌ），那麼計算兩個字串是否是彼此的 angram 的時間複雜度為: O(L)。
此解法的時間複雜度為: O(N ^ 2 * L)。
但是，直接 submit 會得到超時。&lt;/p&gt;
&lt;h2 id=&#34;go&#34;&gt;Go
&lt;/h2&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func isAnagram(s string, t string) bool {
    if len(s) != len(t){
        return false
    }
    appear := map[byte]int{}

    for index := 0 ; index &amp;lt; len(s) ; index += 1{
        if _,ok := appear[s[index]]; !ok{
            appear[s[index]] = 0
        }
        appear[s[index]] += 1
    }
    for index:=0 ; index &amp;lt; len(t) ; index += 1{
        if value,ok := appear[t[index]]; ok &amp;amp;&amp;amp; value &amp;gt; 0{
            appear[t[index]] -= 1
        }else{
            return false
        }
    }
    return true
}
func groupAnagrams(strs []string) [][]string {
    find := map[int]bool{}
    answers := [][]string{}
    for index := 0 ; index &amp;lt; len(strs) ; index +=1{
        answer := []string{}
        if find[index]{
            continue
        }
        find[index] = true
        for second_index := index + 1 ; second_index &amp;lt; len(strs); second_index += 1{
            if find[second_index]{
                continue
            }else{
                if isAnagram(strs[index], strs[second_index]){
                    answer = append(answer,strs[second_index])
                    find[second_index] = true
                }
            }
        }
        answer = append(answer,strs[index])
        answers = append(answers,answer)
    }
    return answers
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;pseudocode---2&#34;&gt;Pseudocode - 2
&lt;/h2&gt;&lt;p&gt;既然超時的話，就要考慮到可以如何降低時間複雜度。
目前是兩兩比較是否是 angram，換個想法來說，其實是兩個字串在比較是否完全是由相同字元組成，但是字元順序可能不同。
那如果字元順序相同的話，是否可以直接比較字串是否相同，甚至是將字串作為 key 放入 hash table，借助 hash table O(1) ~ O(N) 的速度來判斷字串是否出現過就好，便可以縮短兩兩比較所需的 O(N^2) 時間了。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;初始化 hash table &amp;#34;appear&amp;#34; key 是 sorted 過後的字串，value 是陣列，用來存放原本字串。
從第 0 個字串開始，逐一遍例輸入字串陣列的每一個字串：
    排序目前字串
    確認目前排序字串有無出現過，若無出現過：
        初始化 appear[排序目前字串] 為空陣列
    將目前字串加入 appear[排序目前字串]
將 appear 中的所有陣列提取出來，放入到一個陣列後回傳。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;時間複雜度：O(N)
這裡的時間複雜度不包含sort字串。
假設 Ｌ 是字串長度的話（先不考慮所有字串的長度是否都相同為Ｌ），那 sort 字串的時間會再根據 sort 的方法不同而有不同。&lt;/p&gt;
&lt;p&gt;假設都使用語言的 sort function:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Python: O(L log L)&lt;/li&gt;
&lt;li&gt;GO: O(L Log L)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;python&#34;&gt;Python
&lt;/h2&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;def groupAnagrams(self, strs: List[str]) -&amp;gt; List[List[str]]:
    appear = {}
    for word in strs:
        sort_word = &amp;#39;&amp;#39;.join(sorted(word))
        if sort_word not in appear:
            appear[sort_word] = []
        appear[sort_word].append(word)
    answer = []
    for sort_word,words in appear.items():
        answer.append(words)
    return answer
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;go-1&#34;&gt;GO
&lt;/h2&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;import (&amp;#34;sort&amp;#34;
)
func groupAnagrams(strs []string) [][]string {
    appear := map[string][]string{}
    for index:= 0 ; index &amp;lt; len(strs) ; index += 1{
        words := []byte(strs[index])
        sort.Slice(words, func (i,j int) bool {
            return words[i] &amp;lt; words[j]
        })
        sort_words := string(words)
        if _,ok := appear[sort_words];!ok{
            appear[sort_words] = []string{}
        }
        appear[sort_words] = append(appear[sort_words],strs[index])
    }
    answer := [][]string{}
    for _,words := range appear{
            answer = append(answer,words)
    }
    return answer
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;reference&#34;&gt;Reference
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://ithelp.ithome.com.tw/articles/10268906?sc=iThelpR&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://ithelp.ithome.com.tw/articles/10268906?sc=iThelpR&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Leetcode 242</title>
        <link>https://example.com/post/leetcode-242/</link>
        <pubDate>Tue, 29 Apr 2025 18:35:49 +0800</pubDate>
        
        <guid>https://example.com/post/leetcode-242/</guid>
        <description>&lt;h2 id=&#34;題目&#34;&gt;題目
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode.com/problems/valid-anagram&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;242. Valid Anagram&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;給予兩個字串 s 跟 t ， 判斷 t 是否是 s 的 anagram。
是的話回傳 true ， 不是的話，回傳 False。
anagram 指的是 t 字串的字元是否完全來自於 s ，並且每一個字元只被使用一次。&lt;/p&gt;
&lt;h2 id=&#34;pseudocode&#34;&gt;Pseudocode
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://example.com/post/leetcode-217/&#34; &gt;leetcode-217&lt;/a&gt; 的延伸題。&lt;/p&gt;
&lt;p&gt;根據題義可以判斷 s 跟 t 的長度必須相同，所以當長度不同便可直接回傳 false。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;如果 s 的長度不等於 t 的長度:
    回傳 false

從第 0 個字元開始，逐一遍歷 s 的每一個字元:
    紀錄字元出現的頻率
從第 0 個字元開始，逐一遍歷 t 的每一個字元:
    比對字元是否在 s 出現過，以及是否超過 s 的頻率，若並未出現過或超出頻率:
        回傳 false
通過所有檢查，回傳 true
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;時間複雜度:O(N)&lt;/p&gt;
&lt;h2 id=&#34;go&#34;&gt;Go
&lt;/h2&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func isAnagram(s string, t string) bool {
    if len(s) != len(t){
        return false
    }
    appear := map[byte]int{}

    for index := 0 ; index &amp;lt; len(s) ; index += 1{
        if _,ok := appear[s[index]]; !ok{
            appear[s[index]] = 0
        }
        appear[s[index]] += 1
    }
    for index:=0 ; index &amp;lt; len(t) ; index += 1{
        if value,ok := appear[t[index]]; ok &amp;amp;&amp;amp; value &amp;gt; 0{
            appear[t[index]] -= 1
        }else{
            return false
        }
    }
    return true
}
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>Go Map</title>
        <link>https://example.com/post/go-map/</link>
        <pubDate>Tue, 29 Apr 2025 14:37:14 +0800</pubDate>
        
        <guid>https://example.com/post/go-map/</guid>
        <description>&lt;h2 id=&#34;map&#34;&gt;map
&lt;/h2&gt;&lt;p&gt;map 是 Go 中的哈希表（hash table），與 Python 中的 dict 類似。不過，Go 的 map 需要事先定義 key 和 value 的資料型別，並且 key 和 value 必須是相同資料型別的集合。&lt;/p&gt;
&lt;p&gt;map 的型態如下&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;map[KeyType]ValueType
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;宣告&#34;&gt;宣告
&lt;/h3&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;var m map[string][int]
m = make(map[string]int)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在 Go 中，使用 var 宣告一個 map 時，會得到一個 nil map，也就是尚未初始化的狀態。
若在未經初始化的情況下對 map 進行寫入操作（例如新增鍵值對），會得到錯誤訊息:  panic: assignment to entry in nil map
因此，必須使用 make 函數來初始化 map 才能進行寫入。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;m := map[string]int{}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;也可以使用 := 來直接建立空 map，透過此方式建立的 map 可以直接進行寫入。&lt;/p&gt;
&lt;h3 id=&#34;修改新增&#34;&gt;修改/新增
&lt;/h3&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;m[&amp;#34;apple&amp;#34;] = 3
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;map 可以直接透過 key 來新增或修改元素。&lt;/p&gt;
&lt;h3 id=&#34;查詢&#34;&gt;查詢
&lt;/h3&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;m[&amp;#34;apple&amp;#34;]
i := m[&amp;#34;apple&amp;#34;]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;map 可以直接透過 key 來查詢值，若是 key 不存在，會得到值 0。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;value,ok := m[&amp;#34;apple&amp;#34;]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;或著也可以透過兩個 assignment 的方法來確認 key 是否存在在 map。
value 會存放 key 所對應的值，若是 key 不存在於 map 則會是0。
ok 是布林值， true 表示 key 存在於 map， false 表示 key 不存在於 map。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;_,ok := m[&amp;#34;apple&amp;#34;]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果希望在不檢索值的狀況下確認 key，可以使用 _ 。
這樣可以避免宣告了 value 卻沒使用，導致 go 編譯時報錯。&lt;/p&gt;
&lt;h3 id=&#34;刪除&#34;&gt;刪除
&lt;/h3&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;delete(m,&amp;#34;apple&amp;#34;)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以透過 delete 來刪除 key，delete 不會回傳任何東西，若是指定的 key 不存在 map ，則不會做任何事。&lt;/p&gt;
&lt;h3 id=&#34;遍歷&#34;&gt;遍歷
&lt;/h3&gt;&lt;p&gt;map 是無序的，所以不能保證每次遍歷都可以是相同的順序。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main

import &amp;#34;fmt&amp;#34;

func main() {
    m := map[string]int{
        &amp;#34;apple&amp;#34;:  5,
        &amp;#34;banana&amp;#34;: 2,
        &amp;#34;cherry&amp;#34;: 7,
    }
    for key, value := range m {
        fmt.Println(key, value)
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以透過以上的程式碼多跑幾次去測試。
第一次執行可能是&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;apple 5
banana 2
cherry 7
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但第二次執行可能就變成&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;banana 2
cherry 7
apple 5
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;當然也有可能連續兩次執行都是相同順序，所以當有需要 map 以特定順序遍歷的時候，最好是另外儲存 key ，再對 key 進行 sort。&lt;/p&gt;
&lt;h2 id=&#34;參考&#34;&gt;參考
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://go.dev/blog/maps&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://go.dev/blog/maps&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Leetcode 217</title>
        <link>https://example.com/post/leetcode-217/</link>
        <pubDate>Sun, 27 Apr 2025 11:44:03 +0800</pubDate>
        
        <guid>https://example.com/post/leetcode-217/</guid>
        <description>&lt;h2 id=&#34;題目&#34;&gt;題目
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode.com/problems/contains-duplicate/description/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;217. Contains Duplicate&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;給予一個數字陣列 nums，如果陣列中有重複的元素就回傳 True, 否則回傳 False。&lt;/p&gt;
&lt;h2 id=&#34;pseudocode&#34;&gt;Pseudocode
&lt;/h2&gt;&lt;p&gt;這題是蠻簡單的題目，可以透過將元素存入類似 python 的 dict，這類的 hash table 來解決。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;從第 0 個元素開始，逐一遍歷 nums 中的每一個元素:
    如果元素沒有出現過:
        將元素紀錄下來用於比對是否出現過
    如果元束出現過:
        回傳 True 值
當遍歷完 nums 依然沒有重複元素:
回傳 False 值
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;go&#34;&gt;Go
&lt;/h2&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func containsDuplicate(nums []int) bool {
    appear := map[int]bool{}
    for i := 0 ; i &amp;lt; len(nums) ; i ++{
        if _,ok := appear[nums[i]]; ok{
            return true
        }else{
            appear[nums[i]] = true
        }
    }
    return false
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;主要使用了 map 來紀錄出現過的元素。
關於 map 請參考 &lt;a class=&#34;link&#34; href=&#34;https://example.com/post/go-map/&#34; &gt;go-map&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Leetcode 228</title>
        <link>https://example.com/post/leetcode-228/</link>
        <pubDate>Mon, 21 Apr 2025 16:52:48 +0800</pubDate>
        
        <guid>https://example.com/post/leetcode-228/</guid>
        <description>&lt;h2 id=&#34;題目&#34;&gt;題目
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode.com/problems/summary-ranges/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;228. Summart Ranges&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;給予一個 sorted 過的數字陣列，要求依照給定的數字陣列中的連續數字輸出字串陣列。
e.g.
input : [0,1,2,4,5,7]
output : [&amp;ldquo;0-&amp;gt;2&amp;rdquo;,&amp;ldquo;4-&amp;gt;5&amp;rdquo;,&amp;ldquo;7&amp;rdquo;]&lt;/p&gt;
&lt;p&gt;數字陣列中連續數字分別為 [0,1,2] [4,5] [7]。
所以根據題意可以拆解成三個區間字串 &amp;ldquo;0 -&amp;gt; 2&amp;rdquo; , &amp;ldquo;4 -&amp;gt; 5&amp;rdquo; , &amp;ldquo;7&amp;rdquo;&lt;/p&gt;
&lt;p&gt;根據題目說明，數字陣列長度可能為 0 ，所以需要考慮此特殊狀況。
input 的每一個元素都是獨立的，並且從小排到大。&lt;/p&gt;
&lt;h2 id=&#34;pseudocode&#34;&gt;Pseudocode
&lt;/h2&gt;&lt;p&gt;首先，先將應實作邏輯整理出來，好讓後面可以使用不同語言實作。
目的是為了邊學習 go 語言的基本操作。&lt;/p&gt;
&lt;p&gt;先針對特例做處理，當收到一個空陣列的時候，應該回傳一個空陣列，而不是繼續其他操作。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;如果 input 是 空陣列:
    回傳空陣列
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;接下來處理連續數字的邏輯:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;當遍歷 input 的時候，需要確認遍歷的元素是否跟前一個元素是連續的。&lt;/li&gt;
&lt;li&gt;如果不連續的話，便產生一個字串放入需回傳的答案陣列。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;這裡需要兩個陣列:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;temp_arr : 用來存放與確認目前遍歷的元素是否是連續數字所使用。&lt;/li&gt;
&lt;li&gt;answer : 用來存放要回傳的答案。&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# 從第 0 個元素開始存放，迴圈從第 1 個元素開始跟前一個元素比對
初始化 temp_arr 為 [input[0]]
初始化 answer 為空陣列

從第 1 個元素開始，逐一遍歷 input 中的元素:
    如果 當前元素 不等於 temp_arr 最後一個元素 + 1:
        # 表示不連續，需結束目前區間
        將 temp_arr 根據題義轉為區間字串並加入 answer
        初始化 temp_arr 為 [當前元素]
    否則:
        將當前元素加入 temp_arr

# 處理最後一段尚未加入的區間
將 temp_arr 根據題義轉為區間字串並加入 answer

回傳 answer
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;根據題義產生區間字串的過程，由於在遍歷與遍歷完成後都需要使用到，所以另外寫成 function，方便修改。
根據題義產生區間字串會需要連續數字的第 0 個數字 + &amp;ldquo;-&amp;gt;&amp;rdquo; + 最後一個數字。
但是如果如果不連續，只有單一個數字的話，則只要輸出該數字即可。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;字串 = temp_arr 中的第0個元素
如果 temp_arr 的大小超過 1:
    字串加上 &amp;#34;-&amp;gt;&amp;#34; 以及 最後一個元素
回傳字串
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;子函式產生區間字串&#34;&gt;子函式：產生區間字串
&lt;/h3&gt;&lt;p&gt;Input : temp_arr，一個包含連續整數的子區段
Output : 符合題目格式的字串表示，例如 &amp;ldquo;1-&amp;gt;3&amp;rdquo; 或 &amp;ldquo;5&amp;rdquo;&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;初始化 字串 為 temp_arr 的第一個元素（轉成字串）

如果 temp_arr 的長度大於 1:
    將字串加上 &amp;#34;-&amp;gt;&amp;#34; 和 temp_arr 的最後一個元素（轉成字串）

回傳字串
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Note:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果只有一個數字，直接輸出該數字。&lt;/li&gt;
&lt;li&gt;如果是一段連續區間（例如 [1,2,3]），輸出 &amp;ldquo;1-&amp;gt;3&amp;rdquo;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;主函式&#34;&gt;主函式
&lt;/h3&gt;&lt;p&gt;Input : 一個遞增排序的整數陣列 nums（無重複）
output : 將所有連續的整數區段，以字串格式表示的陣列&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;如果 input 是 空陣列:
    回傳空陣列

# 從第 0 個元素開始存放，迴圈從第 1 個元素開始跟前一個元素比對
初始化 temp_arr 為 [input[0]]
初始化 answer 為空陣列

從第 1 個元素開始，逐一遍歷 input 中的元素:
    如果 當前元素 不等於 temp_arr 最後一個元素 + 1:
        # 表示不連續，需結束目前區間
        將 temp_arr 根據題義轉為字串並加入 answer
        初始化 temp_arr 為 [當前元素]
    否則:
        將當前元素加入 temp_arr

# 處理最後一段尚未加入的區間
將 temp_arr 根據題義轉為字串並加入 answer

回傳 answer
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;python&#34;&gt;Python
&lt;/h2&gt;&lt;p&gt;用熟悉的 python 實作，驗證邏輯&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;class Solution:
    def get_answer_string(self,temp_arr: List[int]) -&amp;gt; str:
        answer_string  = f&amp;#34;{temp_arr[0]}&amp;#34;
        if len(temp_arr) &amp;gt; 1:
            answer_string += f&amp;#34;-&amp;gt;{temp_arr[-1]}&amp;#34;
        return answer_string
    def summaryRanges(self, nums: List[int]) -&amp;gt; List[str]:
        if not len(nums):
            return []
        temp_arr = [nums[0]]
        answer = []
        for index in range(1,len(nums)):
            if nums[index] - 1 != temp_arr[-1]:
                answer_string = self.get_answer_string(temp_arr)
                temp_arr = [nums[index]]
                answer.append(answer_string)
            else:
                temp_arr.append(nums[index])
        answer_string = self.get_answer_string(temp_arr)
        answer.append(answer_string)
        return answer
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;go&#34;&gt;GO
&lt;/h2&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;import &amp;#34;strconv&amp;#34;

func get_answer_string(temp_arr [] int) string{
    answer_string := strconv.Itoa(temp_arr[0])
    if len(temp_arr) &amp;gt; 1{
        answer_string += &amp;#34;-&amp;gt;&amp;#34; + strconv.Itoa(temp_arr[len(temp_arr) - 1])
    }
    return answer_string
}
func summaryRanges(nums []int) []string {
    if len(nums) == 0{
        return []string{}
    }
    var temp_arr = []int{}
    var answer = []string{}
    temp_arr = append(temp_arr,nums[0])
    for index := 1 ; index &amp;lt; len(nums); index ++{
        if nums[index] - 1  != temp_arr[len(temp_arr) - 1]{
            answer_string := get_answer_string(temp_arr)
            answer = append(answer,answer_string)
            temp_arr = []int{}
        }
        temp_arr = append(temp_arr,nums[index])
    }
    answer_string := get_answer_string(temp_arr)
    answer = append(answer,answer_string)
return answer
}
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>JWT Note</title>
        <link>https://example.com/post/jwt/</link>
        <pubDate>Tue, 15 Apr 2025 15:34:43 +0800</pubDate>
        
        <guid>https://example.com/post/jwt/</guid>
        <description>&lt;h2 id=&#34;jwt-是什麼&#34;&gt;JWT 是什麼
&lt;/h2&gt;&lt;p&gt;JWT 全名是 JSON Wenb Token，用來以 Json 的方式來傳遞資訊。
JWT 由三個部分組成，並以.做為分隔:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Header
由以下兩個欄位組成，並且使用 Base64 進行編碼，要注意的是 Base64 編碼是可以被逆向解碼的。
&lt;ul&gt;
&lt;li&gt;alg : token 用來加密的演算法&lt;/li&gt;
&lt;li&gt;typ : token 的類型&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Payload
存放要的傳遞資料，除了客製化資料外，也可以使用 JWT 所定義的變數名稱，Payload 一樣是經過 Base64 編碼，不適合用來存放機敏的資料。
以下是一些常見變數，更詳細可以參考 &lt;a class=&#34;link&#34; href=&#34;https://en.wikipedia.org/wiki/JSON_Web_Token&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;wiki&lt;/a&gt;。
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;iss(Issuer) : JWT 的簽發者
sub(Subject) : 主題，可以放用戶id
aud(Audience) : JWT 的接收者
exp(Expiration Time) : JWT 的過期時間
nbf(Not Before) : JWT 在此欄位的時間點，都是不可以使用的
iat(Issued at) : JWT 的簽發時間
jti(JWT ID) : JWT 的唯一身分標示
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;Signature
用於保證資料未被傳改，由 header + . + payload + secret 加密後產生。
secret 為一組字串，存放於伺服器端，如果 secret 外漏，使用者便可以自己產生 JWT&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;如何使用-jwt&#34;&gt;如何使用 JWT
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;使用者登入後，Server 驗證成功後會產生一組 JWT。&lt;/li&gt;
&lt;li&gt;Server 將 JWT 回傳給 Client，Client 會儲存 JWT ，可以存放在 localStorage 或 cookie。&lt;/li&gt;
&lt;li&gt;當 Client 要請求時，必須附上 JWT。&lt;/li&gt;
&lt;li&gt;Server 收到後會去檢查 JWT Token 是否可用。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;優缺點&#34;&gt;優缺點
&lt;/h2&gt;&lt;h3 id=&#34;優點&#34;&gt;優點
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;JWT 可以存放在 Client 端， Server 不用維護 Session。&lt;/li&gt;
&lt;li&gt;可以在不同的網域中使用，因為在前後端分離的話，前後端可能位於不同網域，cookie 無法跨網域使用，所以不能用 cookie 來做身分驗證。使用 JWT 可以在不需登入的情況下，串接多個不同網域的服務。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;缺點&#34;&gt;缺點
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;JWT 無法由 Server 端主動撤銷。&lt;/li&gt;
&lt;li&gt;JWT 的內容並不是加密。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;reference&#34;&gt;Reference
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://kucw.io/blog/jwt/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://kucw.io/blog/jwt/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://en.wikipedia.org/wiki/JSON_Web_Token&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://en.wikipedia.org/wiki/JSON_Web_Token&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://medium.com/%E4%BC%81%E9%B5%9D%E4%B9%9F%E6%87%82%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88/jwt-json-web-token-%E5%8E%9F%E7%90%86%E4%BB%8B%E7%B4%B9-74abfafad7ba&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://medium.com/%E4%BC%81%E9%B5%9D%E4%B9%9F%E6%87%82%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88/jwt-json-web-token-%E5%8E%9F%E7%90%86%E4%BB%8B%E7%B4%B9-74abfafad7ba&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.explainthis.io/zh-hant/swe/jwt&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.explainthis.io/zh-hant/swe/jwt&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://medium.com/@smart_iceberg_goat_568/%E8%A7%80%E5%BF%B5%E7%AD%86%E8%A8%98-jwt-%E8%AA%8D%E8%AD%89%E6%A9%9F%E5%88%B6-5cb7e4e69736&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://medium.com/@smart_iceberg_goat_568/%E8%A7%80%E5%BF%B5%E7%AD%86%E8%A8%98-jwt-%E8%AA%8D%E8%AD%89%E6%A9%9F%E5%88%B6-5cb7e4e69736&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
    </channel>
</rss>
