<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>System Design on Jack&#39;s Note</title>
        <link>https://example.com/categories/system-design/</link>
        <description>Recent content in System Design on Jack&#39;s Note</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-tw</language>
        <lastBuildDate>Tue, 03 Jun 2025 17:05:01 +0800</lastBuildDate><atom:link href="https://example.com/categories/system-design/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>Database Replication</title>
        <link>https://example.com/post/database-replication/</link>
        <pubDate>Tue, 03 Jun 2025 17:05:01 +0800</pubDate>
        
        <guid>https://example.com/post/database-replication/</guid>
        <description>&lt;h2 id=&#34;資料庫複寫database-replication&#34;&gt;資料庫複寫(Database Replication)
&lt;/h2&gt;&lt;p&gt;指的是將資料庫內的資料，複製到不同的資料庫實體上。&lt;/p&gt;
&lt;p&gt;等於是說將資料備份到不同的資料庫上，這樣做的好處是，當一台機器壞掉時，還有其他台機器存有資料。&lt;/p&gt;
&lt;p&gt;例如異地備份，就是將資料存放到不同地點的機器上，來避免天災、人禍導致的資料損失。
另外是可以分配讀取查詢到複數的機器上，提高讀取效率。&lt;/p&gt;
&lt;p&gt;但是分配讀取到不同的資料庫，就需要考慮到寫入是否只能限定哪幾台資料庫，否則可能提升讀取效率卻也會造成資料不一致的問題。&lt;/p&gt;
&lt;h2 id=&#34;主從機制master-slave&#34;&gt;主從機制(Master Slave)
&lt;/h2&gt;&lt;p&gt;主從機制是常見的一種資料庫架構模式，將一個資料庫伺服器設為主資料庫(Master)，將其他多個資料庫伺服器設定為從資料庫(Slave)。&lt;/p&gt;
&lt;h3 id=&#34;主資料庫master&#34;&gt;主資料庫(Master):
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;負責所有的資料寫入。&lt;/li&gt;
&lt;li&gt;將資料變更記錄到log(e.g. mysql binlog)。
&lt;ul&gt;
&lt;li&gt;以 mysql 的 binlog 來說，主資料庫是將變更資料的事件寫到 binlog，從資料庫再向主資料庫 pull binlog ，並根據 binlog 中的事件 replay 操作來更新從資料庫內的資料。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;從資料庫slave&#34;&gt;從資料庫(Slave):
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;不能進行資料寫入。&lt;/li&gt;
&lt;li&gt;用於資料讀取，分散資料讀取的負擔。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;優點&#34;&gt;優點:
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;分散讀取的查詢到不同的資料庫，可以提高查詢的效率。&lt;/li&gt;
&lt;li&gt;當其中一台資料庫出現問題時，可以不用擔心資料遺失，或長時間無法使用服務。
&lt;ul&gt;
&lt;li&gt;主資料庫出現問題時，可以將從資料庫轉換為主資料庫。&lt;/li&gt;
&lt;li&gt;從資料庫出現問題，當只有一台時，可以先將讀取操作導向主資料庫。&lt;/li&gt;
&lt;li&gt;若有多台從資料庫，則先導向其他正常資料庫。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;缺點&#34;&gt;缺點:
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;根據使用的機制不同，如有多個資料庫寫入，需考慮資料同步的問題。&lt;/li&gt;
&lt;li&gt;主資料庫錯誤的話，需要手動將從資料庫轉為主資料庫。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;使用-mysql-建立主從式架構&#34;&gt;使用 mysql 建立主從式架構
&lt;/h2&gt;&lt;p&gt;可以參考我自己建立的&lt;a class=&#34;link&#34; href=&#34;https://github.com/jacketex894/System-design/tree/main/database_replication&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;例子&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;以下會以我自己的範例結構做說明。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;├── docker-compose.yml
├── master-database
│   ├── Dockerfile
│   ├── init.sql
│   ├── my.cnf
└── slave-database
    ├── Dockerfile
    ├── my.cnf
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;這個結構中將主資料庫放在 master-database，從資料庫放在 slave-database，master-datase 跟 slave-database 會各自建立容器，並使用 docker compose 做管理。&lt;/p&gt;
&lt;p&gt;可以先 clone 下來後，執行 docker compose up 後在跟著以下說明進行。&lt;/p&gt;
&lt;h3 id=&#34;docker-composeyml&#34;&gt;docker-compose.yml
&lt;/h3&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;services:
  mysql-master:
    build: ./master-database # 使用指定目錄建構映像
    container_name: mysql-master # 指定容器名稱
    ports:
      # 指定port，要注意的是 mysql default 3306，這裡是將 mysql 修改後的 port 映射到主機的3307
      - &amp;#34;3307:3307&amp;#34; 
    environment:
      # 設定 mysql 密碼為環境變數，需搭配 master-database/Dockerfile 
      MYSQL_ROOT_PASSWORD: test 
    # 設定掛載資料夾
    # mysql 目的是為了重啟容器不遺失資料
    # init.sql 是初始化資料庫時建立 user_db 跟 table users
    # replication 為了備份資料用
    volumes:
      - ./master-database/mysql:/var/lib/mysql
      - ./master-database/init.sql:/docker-entrypoint-initdb.d/init.sql
      - ./master-database/replication:/replication
    # 加入 docker 網路跟 slave 溝通
    networks:
      - mysqlnet

  mysql-slave:
    build: ./slave-database # 使用指定目錄建構映像
    container_name: mysql-slave # 指定容器名稱
    # 指定port，要注意的是 mysql default 3306，這裡是將 mysql 修改後的 port 映射到主機的3308
    ports:
      - &amp;#34;3308:3308&amp;#34;
    environment:
      # 設定 mysql 密碼為環境變數，需搭配 slave-database/Dockerfile
      MYSQL_ROOT_PASSWORD: test
    # 設定掛載資料夾
    # mysql 目的是為了重啟容器不遺失資料
    # replication 為了放 master 的備份資料用
    volumes:
      - ./slave-database/mysql:/var/lib/mysql
      - ./slave-database/replication:/replication
    # 加入 docker 網路跟 slave 溝通
    networks:
      - mysqlnet

networks:
  mysqlnet:
    driver: bridge
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;initsql&#34;&gt;init.sql
&lt;/h3&gt;&lt;p&gt;設想可能在建立主從式架構前，都是只使用一個資料庫來存取資料，但是不夠應付系統需求了，需要建立主從式架構來分散流量。&lt;/p&gt;
&lt;p&gt;所以在我的例子中，可以在 master-database 資料夾中，看到 init.sql。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;CREATE DATABASE user_db ;
USE user_db;
CREATE TABLE users(
    user_id INT AUTO_INCREMENT PRIMARY KEY,
    user_name VARCHAR(255)  UNIQUE NOT NULL,
    mail VARCHAR(255) UNIQUE NOT NULL
);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;目的是為了模擬在設立主從式架構前就有建立 table。&lt;/p&gt;
&lt;p&gt;在設定主從式架構前，如果有資料的話，需要主動備份到從資料庫。&lt;/p&gt;
&lt;p&gt;因為從資料庫不會同步設定主從式架構前的資料。&lt;/p&gt;
&lt;p&gt;這有可能導致 master 有 table users，並且插入了一筆資料。&lt;/p&gt;
&lt;p&gt;但是 slave 並沒有 table users，卻跟著 binlog 中的事件 replay，導致錯誤。&lt;/p&gt;
&lt;p&gt;master 跟 slave 的 replication 掛載資料夾就是為了使用在將主資料庫的資料先備份到從資料庫用的。&lt;/p&gt;
&lt;p&gt;要如何備份會在後續步驟講解，也可以試試沒有備份時直接設定主從，查看在主資料庫插入一筆資料後，從資料庫會報什麼錯誤。&lt;/p&gt;
&lt;p&gt;可以閱讀 &lt;a class=&#34;link&#34; href=&#34;https://dev.mysql.com/doc/refman/9.3/en/replication-implementation.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Replication Implementation&lt;/a&gt; 了解 replication 更詳細的內容。&lt;/p&gt;
&lt;h3 id=&#34;mycnf&#34;&gt;my.cnf
&lt;/h3&gt;&lt;p&gt;以 master-database/my.cnf 內容來說明&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[mysqld]
port=3307
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;將 default 的 port 3306 改成 3307，也可以不設定，default 會為 3306&lt;/p&gt;
&lt;h3 id=&#34;dockerfile&#34;&gt;Dockerfile
&lt;/h3&gt;&lt;p&gt;以 master-database/Dockerfile 內容來說明&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;FROM mysql:8.0
#將 docker compose 設定環境的密碼設定為 sql 的 密碼
ENV MYSQL_ROOT_PASSWORD=$MYSQL_ROOT_PASSWORD

#將設定套用到容器內的 mysql  資料庫
COPY my.cnf /etc/mysql/my.cnf
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;set-up&#34;&gt;Set up
&lt;/h2&gt;&lt;h3 id=&#34;1-設定主資料庫&#34;&gt;1. 設定主資料庫
&lt;/h3&gt;&lt;p&gt;首先需要設定 my.cnf，新增以下內容，或著也可以直接使用範例中的 my.cnf 移除掉註解。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# 設定 server 唯一id
server-id=1
# 設定 binlog 檔案最大容量
max_binlog_size=100M
# 設定記錄檔案名稱
log_bin = mysql-bin
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;將修改後的內容新增到容器內，因為範例建立的容器沒有 vi 或是 nano。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;docker cp ./my.cnf mysql-master:/etc/mysql/my.cnf
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;重啟容器套用設定。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;docker restart mysql-master
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;為了繼續設定，要進入到容器內。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;docker exec -it mysql-master /bin/bash
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;進入到 mysql 內。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;mysql -u root -p
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然後輸入密碼，如果是使用範例的話，密碼是 test。&lt;/p&gt;
&lt;p&gt;以下指令 mysql&amp;gt; 表示進入 mysql 內下達的指令，實際輸入時請忽略。&lt;/p&gt;
&lt;p&gt;此時執行&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;mysql&amp;gt; SHOW DATABASES;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;應該會看到，事先建立好的user_db。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| sys                |
| user_db            |
+--------------------+
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;建立給從資料庫使用的使用者，並指定使用 SHA-256 來加密及驗證密碼&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;mysql&amp;gt; CREATE USER &amp;#39;second&amp;#39;@&amp;#39;%&amp;#39; IDENTIFIED WITH caching_sha2_password BY &amp;#39;test&amp;#39;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;設定使用者的權限。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;mysql&amp;gt; GRANT REPLICATION SLAVE ON *.* TO &amp;#39;second&amp;#39;@&amp;#39;%&amp;#39;;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;重新載入權限，mysql 才能套用上面所設定的使用者權限。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;mysql&amp;gt; FLUSH PRIVILEGES;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;確認設定是否生效。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;mysql&amp;gt; SHOW MASTER STATUS;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;應該會看到類似以下的輸出結果。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;+------------------+----------+--------------+------------------+-------------------+
| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |
+------------------+----------+--------------+------------------+-------------------+
| mysql-bin.000001 |      860 |              |                  |                   |
+------------------+----------+--------------+------------------+-------------------+
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;請記下 File 跟 position 的內容，會在從資料庫的設定使用到。&lt;/p&gt;
&lt;h3 id=&#34;2-備份主資料庫資料到從資料庫&#34;&gt;2. 備份主資料庫資料到從資料庫
&lt;/h3&gt;&lt;p&gt;先將 DB 設定為 read only，如果是正在線上的系統，此舉會影響到所有寫入功能，務必小心。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;mysql&amp;gt; FLUSH TABLES WITH READ LOCK;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;退出 mysql 到 master-sql 的容器下達指令，備份資料。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;mysqldump -uroot -p  --all-databases &amp;gt; replication/master.sql
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;會要求輸入密碼，密碼是 test。&lt;/p&gt;
&lt;p&gt;在容器外，將 master-database 內的 replication 的備份資料複製到 slave-database 底下。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;sudo cp master-database/replication/master.sql slave-database/replication/
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Q: 為什麼要額外掛載 replication?&lt;/p&gt;
&lt;p&gt;A: 額外掛載 replication 是為了備份資料的移轉，也可以透過其他的方式將檔案移道從資料庫底下，並不限制一定只能照此方法執行。&lt;/p&gt;
&lt;p&gt;進入到從資料庫的容器內。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;docker exec -it mysql-slave /bin/bash
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;將備份的資料匯入到從資料庫內，也可以看一下 master.sql 的內容，會發現裡面其實是 SQL 指令的腳本，所以這個動作其實是在從資料庫上 replay 主資料庫的操作。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;mysql -u root -p --default-character-set=utf8 &amp;lt; replication/master.sql
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;會要求輸入密碼，密碼是 test。&lt;/p&gt;
&lt;p&gt;進入到 mysql 內。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;mysql -u root -p
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然後輸入密碼，如果是使用範例的話，密碼是 test。&lt;/p&gt;
&lt;p&gt;此時執行&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;mysql&amp;gt; SHOW DATABASES;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;會看到，成功備份了主資料庫的 user_db。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;+--------------------+
| Database           |
+--------------------+
| information_schema |
| mysql              |
| performance_schema |
| sys                |
| user_db            |
+--------------------+
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;3-設定從資料庫&#34;&gt;3. 設定從資料庫
&lt;/h3&gt;&lt;p&gt;首先需要設定 my.cnf，新增以下內容，或著也可以直接使用範例中的 my.cnf 移除掉註解。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# 設定 server 唯一id
server-id=2
# 設定只能讀取
read_only=ON
# 設定連 root 也只能讀取
super_read_only=ON
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;super_read_only&lt;/code&gt; 這項設定端看使用者需求，如果只設定 &lt;code&gt;read_only&lt;/code&gt; 只會阻擋普通使用者的寫入，並不會阻擋 root 的寫入。&lt;/p&gt;
&lt;p&gt;將修改後的內容新增到容器內，因為範例建立的容器沒有 vi 或是 nano。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;docker cp ./my.cnf mysql-slave:/etc/mysql/my.cnf
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;重啟容器套用設定。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;docker restart mysql-slave
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;進入到 mysql 內。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;mysql -u root -p
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然後輸入密碼，如果是使用範例的話，密碼是 test。&lt;/p&gt;
&lt;p&gt;根據 &lt;code&gt;1. 設定主資料庫&lt;/code&gt; 紀錄的內容設定&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;mysql&amp;gt; CHANGE MASTER TO
MASTER_HOST=&amp;#39;mysql-master&amp;#39;,
MASTER_PORT=3307,
MASTER_USER=&amp;#39;second&amp;#39;,
MASTER_PASSWORD=&amp;#39;test&amp;#39;,
MASTER_LOG_FILE=&amp;#39;mysql-bin.000001&amp;#39;,
MASTER_LOG_POS=860,
GET_MASTER_PUBLIC_KEY = 1;
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;MASTER_HOST : 是設定主資料庫的ip，但這裡是使用docker-compose內的網路，所以根據 service 名稱設定。&lt;/li&gt;
&lt;li&gt;MASTER_PORT : 設定主資料的port，如果沒有設定，預設是走3306，所以如果沒有修改主資料庫的 port 是不用設定此項。&lt;/li&gt;
&lt;li&gt;MASTER_USER : 在 &lt;code&gt;1. 設定主資料庫&lt;/code&gt; 的主資料庫中設定給從資料庫使用的使用者。&lt;/li&gt;
&lt;li&gt;MASTER_PASSWORD : 在 &lt;code&gt;1. 設定主資料庫&lt;/code&gt; 的主資料庫中設定給從資料庫使用的使用者密碼。&lt;/li&gt;
&lt;li&gt;MASTER_LOG_FILE : 在 &lt;code&gt;1. 設定主資料庫&lt;/code&gt; &lt;code&gt;SHOW MASTER STATUS&lt;/code&gt; 顯示的 File，指定從哪個 binary log 檔案開始同步。&lt;/li&gt;
&lt;li&gt;MASTER_LOG_POS : 在 &lt;code&gt;1. 設定主資料庫&lt;/code&gt; &lt;code&gt;SHOW MASTER STATUS&lt;/code&gt; 顯示的 Position，指定 binlog 中的 offset 位置，從該位置開始複製資料。&lt;/li&gt;
&lt;li&gt;GET_MASTER_PUBLIC_KEY : 設定啟用 RSA 公鑰來交換密碼。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;更詳細的設定可以參考 : &lt;a class=&#34;link&#34; href=&#34;https://dev.mysql.com/doc/refman/8.0/en/change-master-to.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;CHANGE MASTER TO Statement&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;啟動從伺服器的同步機制&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;mysql&amp;gt; START SLAVE;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;要注意的是 SQL 版本 如果是 8.0.22 以上的話，&lt;code&gt;START SLAVE&lt;/code&gt; 被改為 &lt;code&gt;START REPLICA&lt;/code&gt;，所以需要注意 SQL 版本。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://dev.mysql.com/doc/refman/8.0/en/start-slave.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;詳細請參考&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;確認從伺服器的狀態&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;mysql&amp;gt; SHOW SLAVE STATUS\G;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;看到以下內容顯示 YES 表示成功了。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Slave_IO_Running: Yes
Slave_SQL_Running: Yes
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;4-設定主資料庫&#34;&gt;4. 設定主資料庫
&lt;/h3&gt;&lt;p&gt;記得要解除 &lt;code&gt;2. 備份主資料庫資料到從資料庫&lt;/code&gt; 主資料庫 的 read only。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;mysql&amp;gt; UNLOCK TABLES;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以嘗試在主資料庫 insert 一筆資料，確認從資料庫是否也有更新。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;mysql&amp;gt; USE user_db;
INSERT INTO users (user_name, mail) VALUES (&amp;#39;test&amp;#39;, &amp;#39;test@mail.com&amp;#39;);
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;參考&#34;&gt;參考:
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;內行人才知道的系統設計面試指南&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://homuchen.com/posts/what-and-why-database-replication-advantage-and-disadvantage/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://homuchen.com/posts/what-and-why-database-replication-advantage-and-disadvantage/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://ithelp.ithome.com.tw/m/articles/10267454&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://ithelp.ithome.com.tw/m/articles/10267454&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://medium.com/dean-lin/%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%B6%E4%BD%A0%E5%AF%A6%E4%BD%9C-mysql-master-slave-replication-16d0a0fa1d04&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://medium.com/dean-lin/%E6%89%8B%E6%8A%8A%E6%89%8B%E5%B8%B6%E4%BD%A0%E5%AF%A6%E4%BD%9C-mysql-master-slave-replication-16d0a0fa1d04&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.toright.com/posts/5062/mysql-replication-%E4%B8%BB%E5%BE%9E%E5%BC%8F%E6%9E%B6%E6%A7%8B%E8%A8%AD%E5%AE%9A%E6%95%99%E5%AD%B8&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://blog.toright.com/posts/5062/mysql-replication-%E4%B8%BB%E5%BE%9E%E5%BC%8F%E6%9E%B6%E6%A7%8B%E8%A8%AD%E5%AE%9A%E6%95%99%E5%AD%B8&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://ithelp.ithome.com.tw/articles/10255421&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://ithelp.ithome.com.tw/articles/10255421&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://dev.mysql.com/doc/refman/9.3/en/replication-implementation.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://dev.mysql.com/doc/refman/9.3/en/replication-implementation.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://dev.mysql.com/doc/refman/8.0/en/replication-howto.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://dev.mysql.com/doc/refman/8.0/en/replication-howto.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://dev.mysql.com/doc/refman/8.0/en/change-master-to.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://dev.mysql.com/doc/refman/8.0/en/change-master-to.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://dev.mysql.com/doc/refman/8.4/en/caching-sha2-pluggable-authentication.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://dev.mysql.com/doc/refman/8.4/en/caching-sha2-pluggable-authentication.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://dev.mysql.com/doc/refman/8.0/en/start-slave.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://dev.mysql.com/doc/refman/8.0/en/start-slave.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>SQL vs NoSQL</title>
        <link>https://example.com/post/sql-vs-nosql/</link>
        <pubDate>Thu, 22 May 2025 11:17:31 +0800</pubDate>
        
        <guid>https://example.com/post/sql-vs-nosql/</guid>
        <description>&lt;h2 id=&#34;sql-structured-query-language&#34;&gt;SQL (Structured Query Language)
&lt;/h2&gt;&lt;p&gt;SQL 是指一種查詢語言，用來跟關聯式資料庫(RDBMS,Relational Database Management System)互動。&lt;/p&gt;
&lt;h3 id=&#34;rdbms-relational-database-management-system&#34;&gt;RDBMS (Relational Database Management System)
&lt;/h3&gt;&lt;p&gt;使用 Table 來儲存管理資料，Table 中會以表格的方式儲存資料，如下所示。&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;user_id&lt;/th&gt;
          &lt;th&gt;user_name&lt;/th&gt;
          &lt;th&gt;email&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;0&lt;/td&gt;
          &lt;td&gt;Jack&lt;/td&gt;
          &lt;td&gt;&lt;a class=&#34;link&#34; href=&#34;mailto:example@test.com&#34; &gt;example@test.com&lt;/a&gt;&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;同一欄位的資料，會規定是要相同的資料型態。&lt;/p&gt;
&lt;p&gt;每個表格會有一個 Primary Key，用來唯一識別每條資料。&lt;/p&gt;
&lt;p&gt;表格跟表格之間可以建立關聯(join)，表示表格可以特過特定的欄位資料來跟另一個表格相互關聯。&lt;/p&gt;
&lt;p&gt;以以下兩張表來做說明&lt;/p&gt;
&lt;p&gt;users&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;user_id&lt;/th&gt;
          &lt;th&gt;user_name&lt;/th&gt;
          &lt;th&gt;email&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;0&lt;/td&gt;
          &lt;td&gt;Jack&lt;/td&gt;
          &lt;td&gt;&lt;a class=&#34;link&#34; href=&#34;mailto:example@test.com&#34; &gt;example@test.com&lt;/a&gt;&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;user_detail&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;user_name&lt;/th&gt;
          &lt;th&gt;Age&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;Jack&lt;/td&gt;
          &lt;td&gt;28&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;假如想要查詢使用者姓名、電子郵件、年齡，可以透過 SQL 語法關聯。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;SELECT users.user_name, users.email, user_details.Age
FROM users
INNER JOIN user_details
ON users.user_name = user_details.user_name;
&lt;/code&gt;&lt;/pre&gt;&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;user_id&lt;/th&gt;
          &lt;th&gt;user_name&lt;/th&gt;
          &lt;th&gt;email&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;0&lt;/td&gt;
          &lt;td&gt;Jack&lt;/td&gt;
          &lt;td&gt;&lt;a class=&#34;link&#34; href=&#34;mailto:example@test.com&#34; &gt;example@test.com&lt;/a&gt;&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;RDBMS 具備 ACID 特性，在資料庫中，使用一筆交易(transaction)來指一組資料庫操作，以下以交易來解釋 ACID。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;原子性(Atomicity):一筆交易中只要有任何操作失敗，就必須回滾(roll back)為交易前的狀態。&lt;/li&gt;
&lt;li&gt;一致性(Consistency):交易前後，資料庫必須保持一致的狀態，交易不會破壞資料庫的完整系。e.g. A 與 B 一共有 200 元，A 轉帳給 B，轉完帳後 A 與 B 依然一共有 200 元。&lt;/li&gt;
&lt;li&gt;隔離性(Isolation):交易之間不會互相干擾。每個交易的執行不應該被其他交易影響，isolation 可以再分為四個級別。&lt;/li&gt;
&lt;li&gt;持久性(Durability):只要資料寫入資料庫，即便是系統崩潰也不會丟失。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;index&#34;&gt;index
&lt;/h3&gt;&lt;p&gt;RDBMS 透過 B-Tree 資料結構來建立索引，並且可以依照排序來儲存索引。&lt;/p&gt;
&lt;h2 id=&#34;nosqlnot-only-sql&#34;&gt;NoSQL(Not only sql)
&lt;/h2&gt;&lt;p&gt;NoSQL 通常指的是不使用表格關聯方式來儲存資料的資料庫，儲存方式多元，以我自己常用的 mongodb 來講，是以 Json 的方式來儲存資料。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[
  {
    &amp;#34;user_id&amp;#34;: 1,
    &amp;#34;user_name&amp;#34;: &amp;#34;Alice&amp;#34;,
    &amp;#34;email&amp;#34;: &amp;#34;alice@example.com&amp;#34;,
    &amp;#34;age&amp;#34;: 30,
  },
  {
    &amp;#34;user_id&amp;#34;: 2,
    &amp;#34;user_name&amp;#34;: &amp;#34;Bob&amp;#34;,
    &amp;#34;email&amp;#34;: &amp;#34;bob@example.com&amp;#34;,
    &amp;#34;age&amp;#34;: 25,
  },
]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;mongodb 一開始並不支援 join，但是後來新增了 $lookup ，其行為類似於 SQL 的 JOIN。&lt;/p&gt;
&lt;p&gt;NoSQL 資料庫通常是用於在分散式系統，所以需要考慮 CAP。&lt;/p&gt;
&lt;h3 id=&#34;cap&#34;&gt;CAP
&lt;/h3&gt;&lt;p&gt;CAP 理論指的是在一個分散式系統中，只能保證以下三者其二。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一致性(Consistency):每次讀取操作都能取得系統中最新寫入的資料。&lt;/li&gt;
&lt;li&gt;可用性(Availability):每次對系統的請求都能得到回覆。&lt;/li&gt;
&lt;li&gt;分區容錯性(Partition Tolernce):當系統的不同節點支籤無法通訊，系統仍然能保持運作。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;index-1&#34;&gt;index
&lt;/h3&gt;&lt;p&gt;NoSQL 使用 Hash function 將資料轉換為 Hash value，但也因此 nosql 的索引是無序的。&lt;/p&gt;
&lt;h2 id=&#34;比較&#34;&gt;比較
&lt;/h2&gt;&lt;h3 id=&#34;縱向擴展-vertical-scaling&#34;&gt;縱向擴展 (Vertical Scaling)
&lt;/h3&gt;&lt;p&gt;縱向擴展指的是透過增加硬體提升效能(e.g.增加 CPU、memory&amp;hellip;)，來提升單個伺服器的效能。&lt;/p&gt;
&lt;p&gt;SQL : 支援，對於 SQL 資料庫來說垂直擴展是最能增加效能的方法，隨著資料量增加，對於硬體的需求也會逐漸提高。&lt;/p&gt;
&lt;p&gt;NoSQL : 支援&lt;/p&gt;
&lt;h3 id=&#34;橫向擴展-horizontal-scaling&#34;&gt;橫向擴展 (Horizontal Scaling)
&lt;/h3&gt;&lt;p&gt;橫向擴展指的是增加更多伺服器或節點來提升效能。&lt;/p&gt;
&lt;p&gt;SQL:支援但不擅長，因為要維持 ACID，而 ACID 在不同 server 之間要維持原子性會非常困難。&lt;/p&gt;
&lt;p&gt;NOSQL:支援，並且由於資料間沒有關聯性，NOSQL 能更好的運作在分散式系統。&lt;/p&gt;
&lt;h3 id=&#34;寫入&#34;&gt;寫入
&lt;/h3&gt;&lt;p&gt;SQL:為了保持ACID，當在處理高併發的大量寫入請求時會消耗更多資源並影響效能。&lt;/p&gt;
&lt;p&gt;NOSQL:NOSQL 在處理高併發的大量寫入請求時，表現會比 SQL 來的好，原因是因為 NOSQL 的資料在寫入時不必立刻同步到所有 server，而是最終資料一致就好。&lt;/p&gt;
&lt;h3 id=&#34;查詢&#34;&gt;查詢
&lt;/h3&gt;&lt;p&gt;SQL:SQL 擅長處理複雜的查詢，特別是涉及多表 Join 以及複雜的過濾條件時。&lt;/p&gt;
&lt;p&gt;NOSQL: 單一紀錄的查詢快，但是複雜的查詢，特別是涉及多表的查詢會相較 SQL 慢。&lt;/p&gt;
&lt;h3 id=&#34;結論&#34;&gt;結論
&lt;/h3&gt;&lt;p&gt;SQL:適合需要 ACID 來保證資料正確，複雜查詢的應用。&lt;/p&gt;
&lt;p&gt;NOSQL:適合高效能寫入，需要在分散式系統運作，可接受最終一致性的應用。&lt;/p&gt;
&lt;h2 id=&#34;補充&#34;&gt;補充
&lt;/h2&gt;&lt;h3 id=&#34;isolation-level&#34;&gt;isolation level
&lt;/h3&gt;&lt;p&gt;isolation 分成 四個 level，分別是為了解決不同狀況的需求。&lt;/p&gt;
&lt;p&gt;先解釋資料庫在儲存時會遇到那些狀況。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Dirty Read : 一個交易向資料庫寫入資料時，還沒 commit，另一個交易卻讀取了尚未 commit 的資料
&lt;ul&gt;
&lt;li&gt;A 交易在一次交易中讀取了兩次資料，但是在第一次資料讀取跟第二次資料讀取之間，B交易將資料改寫了，導致兩次讀取資料的數值不同。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Non-repeatable reads : 同一個交易中讀取了多次資料，但是卻取得了不同的結果
&lt;ul&gt;
&lt;li&gt;A 交易在一次交易中讀取了多次資料，但是在資料讀取間，B交易改寫了資料並 commit，導致了A讀取了相同資料卻取得不同結果。&lt;/li&gt;
&lt;li&gt;Dirty Read 也屬於 Non-repeatable reads 差別在於有沒有 commit&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Phantom reads: 當在同一個交易中，連續讀取資料取得的比數卻不同。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;為了解決這些狀況，於是將 isolation 分成 4 個 level&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Read Uncommited : 可以讀取為 commit 的資料。&lt;/li&gt;
&lt;li&gt;Read Commited: 只能讀取到已 commit 的資料，解決 Dirty Read。&lt;/li&gt;
&lt;li&gt;Repeatable Read: 同一交易中，只要搜尋條件相同，便能取得相同結果，解決 Non-repeatable reads。&lt;/li&gt;
&lt;li&gt;Serializable: 多個 transaction 執行時，只要順序相同，得到的結果便相同，但是因為資料庫會確保 transaction 依序完成，會造成效能降低，解決 Phantom reads。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;參考&#34;&gt;參考:
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://medium.com/appdev-ooops/%E8%B3%87%E6%96%99%E5%BA%AB-%E4%BD%A0%E7%9C%9F%E7%9A%84%E7%94%A8%E5%B0%8D%E4%BA%86%E5%97%8E-sql-vs-nosql-9621a05180d4&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://medium.com/appdev-ooops/%E8%B3%87%E6%96%99%E5%BA%AB-%E4%BD%A0%E7%9C%9F%E7%9A%84%E7%94%A8%E5%B0%8D%E4%BA%86%E5%97%8E-sql-vs-nosql-9621a05180d4&lt;/a&gt;
&lt;a class=&#34;link&#34; href=&#34;https://www.codegym.tech/blog/sql-vs-nosql&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.codegym.tech/blog/sql-vs-nosql&lt;/a&gt;
&lt;a class=&#34;link&#34; href=&#34;https://realnewbie.com/basic-concent/database/sql-vs-nosql-differences-beginner-guide/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://realnewbie.com/basic-concent/database/sql-vs-nosql-differences-beginner-guide/&lt;/a&gt;
&lt;a class=&#34;link&#34; href=&#34;https://oldmo860617.medium.com/%E5%88%9D%E6%AD%A5%E8%AA%8D%E8%AD%98%E5%88%86%E6%95%A3%E5%BC%8F%E8%B3%87%E6%96%99%E5%BA%AB%E8%88%87-nosql-cap-%E7%90%86%E8%AB%96-a02d377938d1&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://oldmo860617.medium.com/%E5%88%9D%E6%AD%A5%E8%AA%8D%E8%AD%98%E5%88%86%E6%95%A3%E5%BC%8F%E8%B3%87%E6%96%99%E5%BA%AB%E8%88%87-nosql-cap-%E7%90%86%E8%AB%96-a02d377938d1&lt;/a&gt;
&lt;a class=&#34;link&#34; href=&#34;https://www.mysql.tw/2024/05/mysql-innodb-isolation-level.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.mysql.tw/2024/05/mysql-innodb-isolation-level.html&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Sqlalchemy</title>
        <link>https://example.com/post/sqlalchemy/</link>
        <pubDate>Tue, 13 May 2025 00:23:14 +0800</pubDate>
        
        <guid>https://example.com/post/sqlalchemy/</guid>
        <description>&lt;h2 id=&#34;前言&#34;&gt;前言
&lt;/h2&gt;&lt;p&gt;學到了 connection pool，想說要來 optimize 自己的 side project。&lt;/p&gt;
&lt;p&gt;沒想到研究了半天，原本使用的 Sqlalchemy 就已經有內建有做了。&lt;/p&gt;
&lt;p&gt;因此做個筆記紀錄一下，也給自己一個警惕，比起請 AI 直接開始改寫，不如先去讀一下官方文件，養成閱讀官方文件的習慣。&lt;/p&gt;
&lt;p&gt;在使用 AI 上也要更小心自己不夠了解的部分，避免被幻覺誤導。&lt;/p&gt;
&lt;h2 id=&#34;connection-pool&#34;&gt;Connection pool
&lt;/h2&gt;&lt;p&gt;每當跟資料庫要求 CRUD 操作時，都需要跟資料庫建立連線、進行操作、關閉連線。
建立連線跟關閉連線的動作對資料庫來說是很消耗資源的，connection pool 就是為了解決消耗資源的問題。&lt;/p&gt;
&lt;p&gt;connection pool 相當於連線的快取，程式會事先建立固定的連線數量，當要跟資料庫要求執行操作時，會從 connection pool 中取得已事先建立好的連線，完成操作後再歸還。&lt;/p&gt;
&lt;p&gt;透過重複使用已建立的連線，來減少每次操作都建立連線再關閉連線所消耗的資源。&lt;/p&gt;
&lt;p&gt;以下會先事先建立好資料庫，用於比較有 connection pool 跟沒有 connection pool
查詢的差異。&lt;/p&gt;
&lt;h2 id=&#34;mysqlconnector&#34;&gt;mysql.connector
&lt;/h2&gt;&lt;p&gt;mysql.connector 是由 MySQL 官方提供的 lib。
會先利用此 lib 的方法來連接資料庫做查詢。&lt;/p&gt;
&lt;p&gt;mysql.connector 的使用方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;透過 mysql.connector.connect 來設定基本設定以及建立連線，這裡不設定 port 是因為在測試範例中使用的是 mysql 的 default port 3306。&lt;/li&gt;
&lt;li&gt;透過 connection.cursor() 建立 cursor，透過 cursor 跟 DB 溝通(傳遞 SQL 指令跟取回結果)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;without_pool&#34;&gt;without_pool
&lt;/h3&gt;&lt;p&gt;每次查詢都會建立連線查詢，再關閉連線。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;def query_with_out_pool():
    connection = None
    cursor = None
    try:
        #建立連線
        connection = mysql.connector.connect(
            host=DB_HOST,
            user=DB_USER,
            passwd=DB_PASSWORD,
            database=DB_NAME
        )
        if connection.is_connected():
            cursor = connection.cursor()
            query = f&amp;#34;&amp;#34;&amp;#34;SELECT name 
            FROM {TABLE_NAME}
            WHERE name = &amp;#39;test_55&amp;#39;&amp;#34;&amp;#34;&amp;#34;
            cursor.execute(query)
            records = cursor.fetchall()
    except Error as e:
        print(f&amp;#34;Database operation error{e}&amp;#34;)
    finally:
        if connection and connection.is_connected():
            if cursor:
                cursor.close()
            connection.close()
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我使用 line_profile 來逐行檢視執行100次所消耗的資源。
會得到以下的輸出&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Wrote profile results to query.py.lprof
Timer unit: 1e-06 s

Total time: 2.9325 s
File: query.py
Function: query_with_out_pool at line 16

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    16                                           @profile
    17                                           def query_with_out_pool():
    18       100         56.4      0.6      0.0      connection = None
    19       100         24.8      0.2      0.0      cursor = None
    20       100         15.0      0.2      0.0      try:
    21       200    2733927.1  13669.6     93.2          connection = mysql.connector.connect(
    22       100         28.4      0.3      0.0              host=DB_HOST,
    23       100         21.5      0.2      0.0              user=DB_USER,
    24       100         17.5      0.2      0.0              passwd=DB_PASSWORD,
    25       100         25.9      0.3      0.0              database=DB_NAME
    26                                                   )
    27       100      29763.2    297.6      1.0          if connection.is_connected():
    28       100      31832.3    318.3      1.1              cursor = connection.cursor()
    29       200         99.7      0.5      0.0              query = f&amp;#34;&amp;#34;&amp;#34;SELECT name
    30       100         62.7      0.6      0.0              FROM {TABLE_NAME}
    31                                                       WHERE name = &amp;#39;test_55&amp;#39;&amp;#34;&amp;#34;&amp;#34;
    32       100      54132.4    541.3      1.8              cursor.execute(query)
    33       100       3652.7     36.5      0.1              records = cursor.fetchall()
    34                                               except Error as e:
    35                                                   print(f&amp;#34;Database operation error{e}&amp;#34;)
    36                                               finally:
    37       100      29637.8    296.4      1.0          if connection and connection.is_connected():
    38       100         59.0      0.6      0.0              if cursor:
    39       100        622.1      6.2      0.0                  cursor.close()
    40       100      48518.0    485.2      1.7              connection.close()

Total time: 2.9357 s
File: query.py
Function: test at line 84

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    84                                           @profile
    85                                           def test():
    86       101         51.7      0.5      0.0      for i in range(0,100):
    87       100    2935643.6  29356.4    100.0          query_with_out_pool()
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以發現有 93.2% 的時間都在建立連線。&lt;/p&gt;
&lt;h3 id=&#34;with_pool&#34;&gt;with_pool
&lt;/h3&gt;&lt;p&gt;mysql.connector 也有提供建立 pool 的方法，可以先建立連線，要使用連線的時候再從 pool 取。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#事先建立好連線
connection_pool = mysql.connector.pooling.MySQLConnectionPool(
            host=DB_HOST,
            user=DB_USER,
            passwd=DB_PASSWORD,
            database=DB_NAME,
            pool_size = 5,
        )

def query_with_pool():
    connection = connection_pool.get_connection()
    cursor = None
    try:
        if connection.is_connected():
            cursor = connection.cursor()
            query = f&amp;#34;&amp;#34;&amp;#34;SELECT name 
            FROM {TABLE_NAME}
            WHERE name = &amp;#39;test_55&amp;#39;&amp;#34;&amp;#34;&amp;#34;
            cursor.execute(query)
            records = cursor.fetchall()
    except Error as e:
        print(f&amp;#34;Database operation error{e}&amp;#34;)
    finally:
        if connection and connection.is_connected():
            if cursor:
                cursor.close()
            connection.close()
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;轉用 pool 後可以發現總消耗時間減少了，並且取用連線的時間也比建立連線短。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Wrote profile results to query.py.lprof
Timer unit: 1e-06 s

Total time: 0.212316 s
File: query.py
Function: query_with_pool at line 49

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    49                                           @profile
    50                                           def query_with_pool():
    51       100      21758.1    217.6     10.2      connection = connection_pool.get_connection()
    52       100         32.5      0.3      0.0      cursor = None
    53       100         15.4      0.2      0.0      try:
    54       100      19519.5    195.2      9.2          if connection.is_connected():
    55       100      21222.9    212.2     10.0              cursor = connection.cursor()
    56       200         86.4      0.4      0.0              query = f&amp;#34;&amp;#34;&amp;#34;SELECT name
    57       100         40.6      0.4      0.0              FROM {TABLE_NAME}
    58                                                       WHERE name = &amp;#39;test_55&amp;#39;&amp;#34;&amp;#34;&amp;#34;
    59       100      40642.8    406.4     19.1              cursor.execute(query)
    60       100       2980.9     29.8      1.4              records = cursor.fetchall()
    61                                               except Error as e:
    62                                                   print(f&amp;#34;Database operation error{e}&amp;#34;)
    63                                               finally:
    64       100      19098.2    191.0      9.0          if connection and connection.is_connected():
    65       100         54.1      0.5      0.0              if cursor:
    66       100        522.8      5.2      0.2                  cursor.close()
    67       100      86341.6    863.4     40.7              connection.close()

Total time: 0.214138 s
File: query.py
Function: test at line 84

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    84                                           @profile
    85                                           def test():
    86       101         35.0      0.3      0.0      for i in range(0,100):
    87       100     214103.5   2141.0    100.0          query_with_pool()
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;sqlalchemy&#34;&gt;sqlalchemy
&lt;/h2&gt;&lt;p&gt;sqlalchemy 是一個 ORM (Object Relational Mapper) library，讓使用者透過物件導向的方式去編寫程式碼，ORM 會再轉譯成 SQL 指令去執行。&lt;/p&gt;
&lt;p&gt;ORM 可以防止 SQL 注入攻擊，但由於轉譯的關係，使用 ORM 也會比原生的 SQL 速度要更慢。&lt;/p&gt;
&lt;p&gt;sqlalchemy default 就有 connection pool。&lt;/p&gt;
&lt;p&gt;以下是一個簡單的 sqlalchemy 範例&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;from sqlalchemy import Column, Integer, String,create_engine
from sqlalchemy.orm import declarative_base
from sqlalchemy.orm import sessionmaker

#建立一個 engine 透過 pymysql 驅動連線
engine = create_engine(f&amp;#34;mysql+pymysql://{DB_USER}:{DB_PASSWORD}@{DB_HOST}:{3306}/{DB_NAME}&amp;#34;)

# 建立一個 ORM 的基礎類別，所有資料表對應的類別都要繼承這個 Base
Base = declarative_base()

# 建立一個 Session 類別，用來建立與資料庫互動的 session（會話）
Session = sessionmaker(bind=engine)

# 定義一個 ORM 類別 User，對應資料庫中的 &amp;#39;test_member&amp;#39; 資料表
class User(Base):
    __tablename__ = &amp;#39;test_member&amp;#39;

    id = Column(Integer, primary_key=True, autoincrement=True)
    name = Column(String(255),nullable=False)

def query_with_pool_sqlalchemy() -&amp;gt; User|None:

        # 建立一個資料庫會話
        session = Session()
        query_user = session.query(User).filter(User.name == &amp;#34;test_55&amp;#34;).first()

        # 關閉 session（釋放資源）
        session.close()
        return query_user
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;sqlalchemy 在使用 pool 的方式比較不同，並非是預先建立好連線。&lt;/p&gt;
&lt;p&gt;而是首次使用的時候才建立連線，而 session.close 則是將資源歸還給 pool，並非關閉連線。&lt;/p&gt;
&lt;p&gt;可以發現使用 sqlalchemy 的時間與 mysql.connector 使用 pool 的時間接近，但稍慢一點，這部分的差異可能就是在於轉譯 SQL 指令所花費的時間。&lt;/p&gt;
&lt;p&gt;可以發現 63.3% 的時間都在 query_uesr 設定 fliter 條件去搜尋這段。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Wrote profile results to query.py.lprof
Timer unit: 1e-06 s

Total time: 0.229665 s
File: query.py
Function: query_with_pool_sqlalchemy at line 78

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    78                                           @profile
    79                                           def query_with_pool_sqlalchemy() -&amp;gt; User|None:
    80       100       3421.0     34.2      1.5          session = Session()
    81       100     145461.8   1454.6     63.3          query_user = session.query(User).filter(User.name == &amp;#34;test_55&amp;#34;).first()
    82       100      80724.5    807.2     35.1          session.close()
    83       100         57.7      0.6      0.0          return query_user

Total time: 0.231337 s
File: query.py
Function: test at line 84

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    84                                           @profile
    85                                           def test():
    86       101         29.0      0.3      0.0      for i in range(0,100):
    87       100     231308.2   2313.1    100.0          query_with_pool_sqlalchemy()
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;sqlalchemy 雖然在預設就有使用 pool，但也有提供使用者自行設定 pool 的參數。
* pool_size    : pool 內有多少連線需要保持
* max_overflow : 設定 pool 中最多可以有多少連線
* pool_recycle : 設定多少秒後回收連線
* pool_timeout : 設定多少秒後放棄從 pool 中取得連線
max_overflow 的用意是當連線都在被使用的時候，最多可以多開到多少連線。
以下是使用例子，作為 &lt;code&gt;create_engine&lt;/code&gt; 的參數傳入即可。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;engine = create_engine(f&amp;#34;mysql+pymysql://{DB_USER}:{DB_PASSWORD}@{DB_HOST}:{3306}/{DB_NAME},pool_size=5, max_overflow=10&amp;#34;)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;更詳細的使用設定可以參考&lt;a class=&#34;link&#34; href=&#34;https://docs.sqlalchemy.org/en/20/core/engines.html#sqlalchemy.create_engine&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;官方文件&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;reference&#34;&gt;Reference
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://en.wikipedia.org/wiki/Connection_pool&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://en.wikipedia.org/wiki/Connection_pool&lt;/a&gt;
&lt;a class=&#34;link&#34; href=&#34;https://vocus.cc/article/5f800406fd89780001365d17&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://vocus.cc/article/5f800406fd89780001365d17&lt;/a&gt;
&lt;a class=&#34;link&#34; href=&#34;https://dev.mysql.com/doc/connector-python/en/connector-python-example-cursor-select.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://dev.mysql.com/doc/connector-python/en/connector-python-example-cursor-select.html&lt;/a&gt;
&lt;a class=&#34;link&#34; href=&#34;https://www.runoob.com/python3/python-mysql-connector.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.runoob.com/python3/python-mysql-connector.html&lt;/a&gt;
&lt;a class=&#34;link&#34; href=&#34;https://dev.mysql.com/doc/connector-python/en/connector-python-connection-pooling.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://dev.mysql.com/doc/connector-python/en/connector-python-connection-pooling.html&lt;/a&gt;
&lt;a class=&#34;link&#34; href=&#34;https://github.com/pyutils/line_profiler&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/pyutils/line_profiler&lt;/a&gt;
&lt;a class=&#34;link&#34; href=&#34;https://reginapanpan.medium.com/sqlalchemy-%E6%98%AF%E4%BB%80%E9%BA%BC-%E8%88%87-orm-%E7%9A%84%E9%97%9C%E4%BF%82-a57b16053aec&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://reginapanpan.medium.com/sqlalchemy-%E6%98%AF%E4%BB%80%E9%BA%BC-%E8%88%87-orm-%E7%9A%84%E9%97%9C%E4%BF%82-a57b16053aec&lt;/a&gt;
&lt;a class=&#34;link&#34; href=&#34;https://www.explainthis.io/zh-hant/swe/orm-intro&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.explainthis.io/zh-hant/swe/orm-intro&lt;/a&gt;
&lt;a class=&#34;link&#34; href=&#34;https://docs.sqlalchemy.org/en/20/core/pooling.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://docs.sqlalchemy.org/en/20/core/pooling.html&lt;/a&gt;
&lt;a class=&#34;link&#34; href=&#34;https://docs.sqlalchemy.org/en/20/core/engines.html#sqlalchemy.create_engine&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://docs.sqlalchemy.org/en/20/core/engines.html#sqlalchemy.create_engine&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>JWT Note</title>
        <link>https://example.com/post/jwt/</link>
        <pubDate>Tue, 15 Apr 2025 15:34:43 +0800</pubDate>
        
        <guid>https://example.com/post/jwt/</guid>
        <description>&lt;h2 id=&#34;jwt-是什麼&#34;&gt;JWT 是什麼
&lt;/h2&gt;&lt;p&gt;JWT 全名是 JSON Wenb Token，用來以 Json 的方式來傳遞資訊。
JWT 由三個部分組成，並以.做為分隔:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Header
由以下兩個欄位組成，並且使用 Base64 進行編碼，要注意的是 Base64 編碼是可以被逆向解碼的。
&lt;ul&gt;
&lt;li&gt;alg : token 用來加密的演算法&lt;/li&gt;
&lt;li&gt;typ : token 的類型&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Payload
存放要的傳遞資料，除了客製化資料外，也可以使用 JWT 所定義的變數名稱，Payload 一樣是經過 Base64 編碼，不適合用來存放機敏的資料。
以下是一些常見變數，更詳細可以參考 &lt;a class=&#34;link&#34; href=&#34;https://en.wikipedia.org/wiki/JSON_Web_Token&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;wiki&lt;/a&gt;。
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;iss(Issuer) : JWT 的簽發者
sub(Subject) : 主題，可以放用戶id
aud(Audience) : JWT 的接收者
exp(Expiration Time) : JWT 的過期時間
nbf(Not Before) : JWT 在此欄位的時間點，都是不可以使用的
iat(Issued at) : JWT 的簽發時間
jti(JWT ID) : JWT 的唯一身分標示
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;Signature
用於保證資料未被傳改，由 header + . + payload + secret 加密後產生。
secret 為一組字串，存放於伺服器端，如果 secret 外漏，使用者便可以自己產生 JWT&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;如何使用-jwt&#34;&gt;如何使用 JWT
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;使用者登入後，Server 驗證成功後會產生一組 JWT。&lt;/li&gt;
&lt;li&gt;Server 將 JWT 回傳給 Client，Client 會儲存 JWT ，可以存放在 localStorage 或 cookie。&lt;/li&gt;
&lt;li&gt;當 Client 要請求時，必須附上 JWT。&lt;/li&gt;
&lt;li&gt;Server 收到後會去檢查 JWT Token 是否可用。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;優缺點&#34;&gt;優缺點
&lt;/h2&gt;&lt;h3 id=&#34;優點&#34;&gt;優點
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;JWT 可以存放在 Client 端， Server 不用維護 Session。&lt;/li&gt;
&lt;li&gt;可以在不同的網域中使用，因為在前後端分離的話，前後端可能位於不同網域，cookie 無法跨網域使用，所以不能用 cookie 來做身分驗證。使用 JWT 可以在不需登入的情況下，串接多個不同網域的服務。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;缺點&#34;&gt;缺點
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;JWT 無法由 Server 端主動撤銷。&lt;/li&gt;
&lt;li&gt;JWT 的內容並不是加密。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;reference&#34;&gt;Reference
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://kucw.io/blog/jwt/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://kucw.io/blog/jwt/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://en.wikipedia.org/wiki/JSON_Web_Token&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://en.wikipedia.org/wiki/JSON_Web_Token&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://medium.com/%E4%BC%81%E9%B5%9D%E4%B9%9F%E6%87%82%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88/jwt-json-web-token-%E5%8E%9F%E7%90%86%E4%BB%8B%E7%B4%B9-74abfafad7ba&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://medium.com/%E4%BC%81%E9%B5%9D%E4%B9%9F%E6%87%82%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88/jwt-json-web-token-%E5%8E%9F%E7%90%86%E4%BB%8B%E7%B4%B9-74abfafad7ba&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.explainthis.io/zh-hant/swe/jwt&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.explainthis.io/zh-hant/swe/jwt&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://medium.com/@smart_iceberg_goat_568/%E8%A7%80%E5%BF%B5%E7%AD%86%E8%A8%98-jwt-%E8%AA%8D%E8%AD%89%E6%A9%9F%E5%88%B6-5cb7e4e69736&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://medium.com/@smart_iceberg_goat_568/%E8%A7%80%E5%BF%B5%E7%AD%86%E8%A8%98-jwt-%E8%AA%8D%E8%AD%89%E6%A9%9F%E5%88%B6-5cb7e4e69736&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
    </channel>
</rss>
